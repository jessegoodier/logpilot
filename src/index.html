<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon" href="https://raw.githubusercontent.com/jessegoodier/logPilot/refs/heads/main/src/images/favicon.ico">
    <title>logPilot</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom scrollbar for webkit browsers */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #2d3748; /* dark:gray-700 */
        }
        ::-webkit-scrollbar-thumb {
            background: #4a5568; /* dark:gray-600 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #718096; /* dark:gray-500 */
        }
        .log-line mark { /* For search highlighting */
            background-color: #f6e05e; /* yellow-300 */
            color: #2d3748; /* gray-800 */
            padding: 0.1em;
            border-radius: 0.2em;
        }
        /* Basic transition for theme toggle */
        body, .bg-gray-100, .bg-gray-800, .text-gray-900, .text-gray-100 {
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .loader {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* ANSI Color Classes */
        .ansi-black { color: #2d3748; }
        .ansi-red { color: #e53e3e; }
        .ansi-green { color: #38a169; }
        .ansi-yellow { color: #d69e2e; }
        .ansi-blue { color: #3182ce; }
        .ansi-magenta { color: #d53f8c; }
        .ansi-cyan { color: #319795; }
        .ansi-white { color: #f7fafc; }

        .ansi-bright-black { color: #4a5568; }
        .ansi-bright-red { color: #fc8181; }
        .ansi-bright-green { color: #68d391; }
        .ansi-bright-yellow { color: #f6e05e; }
        .ansi-bright-blue { color: #63b3ed; }
        .ansi-bright-magenta { color: #f687b3; }
        .ansi-bright-cyan { color: #4fd1c7; }
        .ansi-bright-white { color: #ffffff; }

        /* Dark mode ANSI colors */
        .dark .ansi-black { color: #718096; }
        .dark .ansi-red { color: #fc8181; }
        .dark .ansi-green { color: #68d391; }
        .dark .ansi-yellow { color: #f6e05e; }
        .dark .ansi-blue { color: #63b3ed; }
        .dark .ansi-magenta { color: #f687b3; }
        .dark .ansi-cyan { color: #4fd1c7; }
        .dark .ansi-white { color: #f7fafc; }

        /* Error styling */
        .log-error {
            background-color: #fed7d7;
            color: #c53030;
            border-left: 4px solid #e53e3e;
            padding: 0.25rem 0.5rem;
            margin: 0.125rem 0;
        }
        .dark .log-error {
            background-color: #742a2a;
            color: #fc8181;
            border-left-color: #fc8181;
        }

        /* Retry button styling */
        .retry-button {
            display: inline-block;
            margin-left: 0.5rem;
            padding: 0.125rem 0.25rem;
            background-color: #4299e1;
            color: white;
            border: none;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            cursor: pointer;
            text-decoration: none;
        }
        .retry-button:hover {
            background-color: #3182ce;
        }
    </style>
    <script>
        // Tailwind dark mode configuration
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 font-sans antialiased">

    <div class="container mx-auto px-2 py-2 min-h-screen flex flex-col">
        <header class="bg-white dark:bg-gray-800 shadow-md rounded-lg p-2 mb-2 sticky top-0 z-10">
            <div class="relative">
                <button id="settingsButton" class="absolute top-0 right-0 p-1.5 rounded-md hover:bg-gray-200 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                    <img src="https://raw.githubusercontent.com/jessegoodier/logPilot/refs/heads/main/src/images/settings-gear.png" alt="Settings" class="w-5 h-5">
                </button>
                <div id="settingsMenu" class="hidden absolute right-0 mt-2 w-64 rounded-md shadow-lg bg-white dark:bg-gray-800 ring-1 ring-black ring-opacity-5 z-20">
                    <div class="py-1" role="menu" aria-orientation="vertical">
                        <div class="px-4 py-2 border-b border-gray-200 dark:border-gray-700">
                            <h3 class="text-sm font-medium text-gray-900 dark:text-gray-100">Settings</h3>
                        </div>

                        <div class="px-4 py-2">
                            <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Theme</label>
                            <div class="space-y-2">
                                <div class="flex items-center">
                                    <input type="radio" id="themeLight" name="theme" value="light" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 dark:border-gray-600">
                                    <label for="themeLight" class="ml-2 block text-sm text-gray-700 dark:text-gray-300">
                                        Light
                                    </label>
                                </div>
                                <div class="flex items-center">
                                    <input type="radio" id="themeDark" name="theme" value="dark" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 dark:border-gray-600">
                                    <label for="themeDark" class="ml-2 block text-sm text-gray-700 dark:text-gray-300">
                                        Dark
                                    </label>
                                </div>
                            </div>
                        </div>

                        <div class="px-4 py-2">
                            <label for="sortOrder" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Sort Order</label>
                            <select id="sortOrder" class="mt-1 block w-full py-2 px-3 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                                <option value="desc">Newest First</option>
                                <option value="asc">Oldest First</option>
                            </select>
                        </div>

                        <div class="px-4 py-2">
                            <label for="numLines" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Lines per Page</label>
                            <select id="numLines" class="mt-1 block w-full py-2 px-3 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                                <option value="100">Last 100</option>
                                <option value="1000">Last 1000</option>
                                <option value="0">All</option>
                            </select>
                        </div>

                        <div class="px-4 py-2">
                            <label for="timestampType" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Timestamp Format</label>
                            <select id="timestampType" class="mt-1 block w-full py-2 px-3 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                                <option value="since">Time Since</option>
                                <option value="utc">UTC</option>
                            </select>
                        </div>

                        <div class="px-4 py-2">
                            <div class="flex items-center">
                                <input type="checkbox" id="excludeSelf" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded" checked>
                                <label for="excludeSelf" class="ml-2 block text-sm text-gray-700 dark:text-gray-300">
                                    Exclude Self
                                </label>
                            </div>
                        </div>

                        <div class="px-4 py-2 border-t border-gray-200 dark:border-gray-700">
                            <button id="storageStatsButton" class="w-full py-2 px-3 mb-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 dark:bg-indigo-500 dark:hover:bg-indigo-600">
                                Storage Stats
                            </button>
                            <button id="resetLogSessionButton" class="w-full py-2 px-3 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-orange-600 hover:bg-orange-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-orange-500 dark:bg-orange-500 dark:hover:bg-orange-600" title="Reset log continuity session to start fresh">
                                Reset Log Session
                            </button>
                        </div>

                        <div class="px-4 py-2 border-t border-gray-200 dark:border-gray-700">
                            <div class="text-xs text-gray-500 dark:text-gray-400 text-center">
                                Version: <span id="appVersion">Loading...</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- View Mode Toggle -->
            <div class="mb-4">
                <div class="flex bg-gray-200 dark:bg-gray-700 rounded-lg p-1 w-fit">
                    <button id="logsToggle" class="px-4 py-2 text-sm font-medium rounded-md transition-colors bg-white dark:bg-gray-600 text-gray-900 dark:text-gray-100 shadow-sm">
                        📋 Logs
                    </button>
                    <button id="eventsToggle" class="px-4 py-2 text-sm font-medium rounded-md transition-colors text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100">
                        📅 Events
                    </button>
                </div>
            </div>

            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 items-end mt-2">
                <div>
                    <label for="podSelector" class="block text-sm font-medium text-gray-700 dark:text-gray-300"><span id="selectorLabel">Pod</span> <a href="#" id="refreshPods" class="text-indigo-600 dark:text-indigo-400 hover:text-indigo-800 dark:hover:text-indigo-300 text-xs">(Refresh)</a></label>
                    <select id="podSelector" class="mt-1 block w-full py-2 px-3 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                        <option value="all">All Pods</option>
                    </select>
                </div>

                <div>
                    <label for="searchBox" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Search <a href="#" id="clearSearch" class="text-indigo-600 dark:text-indigo-400 hover:text-indigo-800 dark:hover:text-indigo-300 text-xs">(Clear)</a></label>
                    <div class="mt-1 relative">
                        <input type="text" id="searchBox" placeholder="Enter to search..." title="Search searches all available logs, not just the current page. Results are then limited by Lines per Page setting." class="block w-full py-2 px-3 pr-24 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                        <div class="absolute inset-y-0 right-0 pr-3 flex items-center space-x-2">
                            <button id="highlightToggle" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 focus:outline-none" title="Toggle search term highlighting">
                                <span class="text-sm font-mono">H</span>
                            </button>
                            <button id="caseSensitiveToggle" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 focus:outline-none" title="Toggle case sensitivity">
                                <span class="text-sm font-mono">Aa</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Download Controls -->
            <div id="downloadControls" class="flex flex-wrap gap-2 mt-3">
                <button id="downloadCurrentLog" class="px-3 py-1.5 bg-blue-600 hover:bg-blue-700 text-white rounded-md text-xs font-medium focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed" title="Download log for selected container">
                    Download Current Log
                </button>
                <button id="downloadPodLogs" class="px-3 py-1.5 bg-green-600 hover:bg-green-700 text-white rounded-md text-xs font-medium focus:outline-none focus:ring-2 focus:ring-green-500 disabled:opacity-50 disabled:cursor-not-allowed" title="Download logs for all containers in the selected pod as zip">
                    Download Pod Logs (.zip)
                </button>
                <button id="downloadAllLogs" class="px-3 py-1.5 bg-purple-600 hover:bg-purple-700 text-white rounded-md text-xs font-medium focus:outline-none focus:ring-2 focus:ring-purple-500 disabled:opacity-50 disabled:cursor-not-allowed" title="Download all logs available as zip">
                    Download All Logs (.zip)
                </button>
            </div>
            <div id="namespaceDisplay" class="mt-3 text-xs text-gray-500 dark:text-gray-400">Namespace: <span id="namespaceValue">Loading...</span></div>
            <div id="errorDisplay" class="mt-2 text-sm text-red-600 dark:text-red-400"></div>
            <div id="loadingIndicator" class="hidden mt-2">
                <div class="loader"></div>
                <p id="loadingText" class="text-center text-sm text-gray-500 dark:text-gray-400">Loading...</p>
            </div>
        </header>

        <main class="flex-grow bg-white dark:bg-gray-800 shadow-md rounded-lg p-2 overflow-hidden">
            <pre id="logOutput" class="whitespace-pre-wrap break-all overflow-auto h-full text-sm leading-relaxed"></pre>
        </main>
    </div>

    <!-- Storage Stats Modal -->
    <div id="storageStatsModal" class="hidden fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full mx-4">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-medium text-gray-900 dark:text-gray-100">Storage Statistics</h3>
                <button id="closeStorageStats" class="text-gray-400 hover:text-gray-500 focus:outline-none">
                    <span class="sr-only">Close</span>
                    <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            <div id="storageStatsContent" class="space-y-4">
                <div class="animate-pulse">
                    <div class="h-4 bg-gray-200 dark:bg-gray-700 rounded w-3/4 mb-2"></div>
                    <div class="h-4 bg-gray-200 dark:bg-gray-700 rounded w-1/2 mb-2"></div>
                    <div class="h-4 bg-gray-200 dark:bg-gray-700 rounded w-2/3"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const podSelector = document.getElementById('podSelector');
            const sortOrder = document.getElementById('sortOrder');
            const numLines = document.getElementById('numLines');
            const timestampType = document.getElementById('timestampType');
            const searchBox = document.getElementById('searchBox');
            const themeLight = document.getElementById('themeLight');
            const themeDark = document.getElementById('themeDark');
            const logOutput = document.getElementById('logOutput');
            const namespaceValue = document.getElementById('namespaceValue');
            const errorDisplay = document.getElementById('errorDisplay');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const clearSearch = document.getElementById('clearSearch');
            const refreshPods = document.getElementById('refreshPods');
            const settingsButton = document.getElementById('settingsButton');
            const settingsMenu = document.getElementById('settingsMenu');
            const excludeSelf = document.getElementById('excludeSelf');
            const storageStatsButton = document.getElementById('storageStatsButton');
            const storageStatsModal = document.getElementById('storageStatsModal');
            const closeStorageStats = document.getElementById('closeStorageStats');
            const storageStatsContent = document.getElementById('storageStatsContent');
            const appVersion = document.getElementById('appVersion');
            const caseSensitiveToggle = document.getElementById('caseSensitiveToggle');
            const highlightToggle = document.getElementById('highlightToggle');
            const downloadCurrentLog = document.getElementById('downloadCurrentLog');
            const downloadPodLogs = document.getElementById('downloadPodLogs');
            const downloadAllLogs = document.getElementById('downloadAllLogs');
            const logsToggle = document.getElementById('logsToggle');
            const eventsToggle = document.getElementById('eventsToggle');
            const selectorLabel = document.getElementById('selectorLabel');
            const resetLogSessionButton = document.getElementById('resetLogSessionButton');

            // Hide/show elements based on view mode
            function updateUIElementsForViewMode() {
                const downloadControls = document.getElementById('downloadControls');
                const loadingText = document.getElementById('loadingText');
                if (viewMode === 'logs') {
                    // Show log-related UI elements
                    downloadControls.style.display = 'flex';
                    loadingText.textContent = 'Loading logs...';
                } else if (viewMode === 'events') {
                    // Hide download controls for events view
                    downloadControls.style.display = 'none';
                    loadingText.textContent = 'Loading events...';
                }
            }

            let currentLogs = [];
            let currentEvents = [];
            let currentPodName = null;
            let caseSensitive = localStorage.getItem('caseSensitive') === 'true';
            let highlightEnabled = localStorage.getItem('highlightEnabled') !== 'false'; // Default to true if not set
            let viewMode = localStorage.getItem('viewMode') || 'logs'; // 'logs' or 'events'
            
            // Enhanced log management with client-side buffering
            let logSessionId = null;
            let logBuffer = new Map(); // Key: container_key, Value: {logs: [], lastUpdate: timestamp}
            let seenLineIds = new Set(); // Global set of seen line IDs for additional deduplication

            // Shared color mapping for consistent colors across logs and events
            let globalPodColorMap = new Map();
            let globalColorIndex = 0;
            
            // Enhanced log management functions
            function resetLogSession() {
                logSessionId = null;
                logBuffer.clear();
                seenLineIds.clear();
                console.log('Log session reset');
            }
            
            function addLogsToBuffer(containerKey, newLogs) {
                if (!logBuffer.has(containerKey)) {
                    logBuffer.set(containerKey, {logs: [], lastUpdate: Date.now()});
                }
                
                const buffer = logBuffer.get(containerKey);
                let addedCount = 0;
                
                for (const log of newLogs) {
                    // Additional client-side deduplication
                    if (!seenLineIds.has(log.line_id)) {
                        buffer.logs.push(log);
                        seenLineIds.add(log.line_id);
                        addedCount++;
                    }
                }
                
                buffer.lastUpdate = Date.now();
                console.log(`Added ${addedCount} new logs to buffer for ${containerKey}. Total: ${buffer.logs.length}`);
                
                // Clean up old buffer entries (keep last 1000 logs per container)
                if (buffer.logs.length > 1000) {
                    const removed = buffer.logs.splice(0, buffer.logs.length - 1000);
                    console.log(`Removed ${removed.length} old logs from buffer for ${containerKey}`);
                }
                
                return addedCount;
            }
            
            function getBufferedLogs(containerKey = null) {
                if (containerKey) {
                    const buffer = logBuffer.get(containerKey);
                    return buffer ? [...buffer.logs] : [];
                }
                
                // Return all buffered logs from all containers
                const allLogs = [];
                for (const buffer of logBuffer.values()) {
                    allLogs.push(...buffer.logs);
                }
                
                // Sort by timestamp for consistency
                allLogs.sort((a, b) => {
                    const timeA = a.timestamp || '0000-00-00T00:00:00Z';
                    const timeB = b.timestamp || '0000-00-00T00:00:00Z';
                    return timeA.localeCompare(timeB);
                });
                
                return allLogs;
            }
            
            function clearLogBuffer(containerKey = null) {
                if (containerKey) {
                    logBuffer.delete(containerKey);
                    console.log(`Cleared buffer for ${containerKey}`);
                } else {
                    logBuffer.clear();
                    seenLineIds.clear();
                    console.log('Cleared all log buffers');
                }
            }

            // Define pod colors - using a mix of colors that work well in both light and dark modes
            const podColors = [
                ['text-blue-600', 'dark:text-blue-400'],
                ['text-purple-600', 'dark:text-purple-400'],
                ['text-cyan-600', 'dark:text-cyan-400'],
                ['text-emerald-600', 'dark:text-emerald-400'],
                ['text-amber-600', 'dark:text-amber-400'],
                ['text-rose-600', 'dark:text-rose-400'],
                ['text-violet-600', 'dark:text-violet-400'],
                ['text-teal-600', 'dark:text-teal-400'],
                ['text-orange-600', 'dark:text-orange-400'],
                ['text-pink-600', 'dark:text-pink-400']
            ];

            function getOrCreateColorMapping() {
                return {
                    podColorMap: globalPodColorMap,
                    colorIndex: globalColorIndex,
                    updateColorIndex: (newIndex) => { globalColorIndex = newIndex; }
                };
            }

            // --- Version Information ---
            async function fetchVersion() {
                try {
                    const versionData = await fetchFromServer('/api/version');
                    appVersion.textContent = versionData.version || 'Unknown';
                } catch (error) {
                    console.warn('Could not fetch version information:', error.message);
                    appVersion.textContent = 'Unknown';
                }
            }

            // --- Storage Stats Modal ---
            async function updateStorageStats() {
                try {
                    const [stats, capability, archivedPods] = await Promise.all([
                        fetchFromServer('/api/logDirStats'),
                        fetchFromServer('/api/purgeCapability'),
                        fetchFromServer('/api/archived_pods')
                    ]);
                    let content = '';

                    if (stats.enabled) {
                        const hasPreviousPods = archivedPods.archived_pods && archivedPods.archived_pods.length > 0;
                        const purgeButtonHtml = capability.purge_allowed && hasPreviousPods
                            ? `<div class="pt-4 border-t border-gray-200 dark:border-gray-700">
                                    <button id="purgePreviousLogsButton" class="w-full py-2 px-3 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 dark:bg-red-500 dark:hover:bg-red-600">
                                        Purge Previous Pod Logs
                                    </button>
                                </div>`
                            : '';

                        content = `
                            <div class="space-y-4">
                                <div>
                                    <h4 class="text-sm font-medium text-gray-700 dark:text-gray-300">Total Size</h4>
                                    <p class="text-lg font-semibold text-gray-900 dark:text-gray-100">${stats.total_size_mibytes.toFixed(2)} MiB</p>
                                </div>
                                <div>
                                    <h4 class="text-sm font-medium text-gray-700 dark:text-gray-300">Number of Files</h4>
                                    <p class="text-lg font-semibold text-gray-900 dark:text-gray-100">${stats.file_count}</p>
                                </div>
                                <div>
                                    <h4 class="text-sm font-medium text-gray-700 dark:text-gray-300">Oldest File</h4>
                                    <p class="text-lg font-semibold text-gray-900 dark:text-gray-100">${stats.oldest_file_date || 'N/A'}</p>
                                </div>
                                <div>
                                    <h4 class="text-sm font-medium text-gray-700 dark:text-gray-300">Log Directory</h4>
                                    <p class="text-lg font-semibold text-gray-900 dark:text-gray-100">${stats.log_directory}</p>
                                </div>
                                ${purgeButtonHtml}
                            </div>
                        `;
                    } else {
                        content = `
                            <div class="text-center py-4">
                                <p class="text-gray-700 dark:text-gray-300">${stats.message}</p>
                            </div>
                        `;
                    }
                    storageStatsContent.innerHTML = content;
                } catch (error) {
                    storageStatsContent.innerHTML = `
                        <div class="text-center py-4">
                            <p class="text-red-600 dark:text-red-400">Error loading storage stats: ${error.message}</p>
                        </div>
                    `;
                }
            }

            // Add event delegation for the purge button
            storageStatsContent.addEventListener('click', async (event) => {
                if (event.target.id === 'purgePreviousLogsButton') {
                    if (!confirm('Are you sure you want to delete all previous pod log files? This action cannot be undone.')) {
                        return;
                    }

                    try {
                        const response = await fetchFromServer('/api/purgePreviousLogs', {
                            method: 'POST'
                        });

                        if (response.success) {
                            alert(`Successfully purged ${response.deleted_count} previous pod log files.`);
                            // Close the modal
                            storageStatsModal.classList.add('hidden');
                            // Set pod selector to "all"
                            podSelector.value = "all";
                            // Refresh the pod list and logs
                            await fetchPods();
                        } else {
                            alert(`Error: ${response.message}`);
                        }
                    } catch (error) {
                        alert(`Error purging previous pod logs: ${error.message}`);
                    }
                }
            });

            storageStatsButton.addEventListener('click', () => {
                settingsMenu.classList.add('hidden');
                storageStatsModal.classList.remove('hidden');
                updateStorageStats();
            });

            resetLogSessionButton.addEventListener('click', () => {
                settingsMenu.classList.add('hidden');
                if (confirm('Reset log session? This will clear all buffered logs and restart continuity tracking.')) {
                    resetLogSession();
                    // Trigger a fresh fetch with reset_session=true parameter
                    const params = new URLSearchParams(window.location.search);
                    const apiKey = params.get('api_key');
                    
                    const resetParams = new URLSearchParams({
                        pod_name: podSelector.value || 'all',
                        reset_session: 'true'
                    });
                    
                    if (apiKey) {
                        resetParams.set('api_key', apiKey);
                    }
                    
                    fetchFromServer(`/api/logs?${resetParams.toString()}`)
                        .then(data => {
                            console.log('Session reset successful:', data);
                            // Trigger a normal fetch to repopulate
                            fetchAndDisplayData();
                        })
                        .catch(error => {
                            console.error('Error resetting session:', error);
                            // Still trigger normal fetch
                            fetchAndDisplayData();
                        });
                }
            });

            closeStorageStats.addEventListener('click', () => {
                storageStatsModal.classList.add('hidden');
            });

            // Close modal when clicking outside
            storageStatsModal.addEventListener('click', (event) => {
                if (event.target === storageStatsModal) {
                    storageStatsModal.classList.add('hidden');
                }
            });

            // Close modal with Escape key
            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape' && !storageStatsModal.classList.contains('hidden')) {
                    storageStatsModal.classList.add('hidden');
                }
            });

            // --- Theme Toggle ---
            const applyTheme = () => {
                if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                    document.documentElement.classList.add('dark');
                    themeDark.checked = true;
                } else {
                    document.documentElement.classList.remove('dark');
                    themeLight.checked = true;
                }
            };

            themeLight.addEventListener('change', () => {
                if (themeLight.checked) {
                    localStorage.theme = 'light';
                    applyTheme();
                }
            });

            themeDark.addEventListener('change', () => {
                if (themeDark.checked) {
                    localStorage.theme = 'dark';
                    applyTheme();
                }
            });

            applyTheme();

            // --- Case Sensitivity Toggle ---
            const updateCaseSensitiveDisplay = () => {
                if (caseSensitive) {
                    caseSensitiveToggle.classList.remove('text-gray-400');
                    caseSensitiveToggle.classList.add('text-indigo-600', 'dark:text-indigo-400');
                    caseSensitiveToggle.title = 'Case sensitive search (click to toggle)';
                } else {
                    caseSensitiveToggle.classList.remove('text-indigo-600', 'dark:text-indigo-400');
                    caseSensitiveToggle.classList.add('text-gray-400');
                    caseSensitiveToggle.title = 'Case insensitive search (click to toggle)';
                }
            };

            // --- Highlight Toggle ---
            const updateHighlightDisplay = () => {
                if (highlightEnabled) {
                    highlightToggle.classList.remove('text-gray-400');
                    highlightToggle.classList.add('text-indigo-600', 'dark:text-indigo-400');
                    highlightToggle.title = 'Search term highlighting enabled (click to toggle)';
                } else {
                    highlightToggle.classList.remove('text-indigo-600', 'dark:text-indigo-400');
                    highlightToggle.classList.add('text-gray-400');
                    highlightToggle.title = 'Search term highlighting disabled (click to toggle)';
                }
            };

            caseSensitiveToggle.addEventListener('click', (event) => {
                event.preventDefault();
                caseSensitive = !caseSensitive;
                localStorage.setItem('caseSensitive', caseSensitive.toString());
                updateCaseSensitiveDisplay();
                if (searchBox.value.trim()) {
                    fetchAndDisplayData();
                }
            });

            highlightToggle.addEventListener('click', (event) => {
                event.preventDefault();
                highlightEnabled = !highlightEnabled;
                localStorage.setItem('highlightEnabled', highlightEnabled.toString());
                updateHighlightDisplay();
                // Just re-render since we don't need to fetch again
                if (viewMode === 'logs') {
                    renderLogs();
                } else {
                    renderEvents();
                }
            });

            // Initialize display states
            updateCaseSensitiveDisplay();
            updateHighlightDisplay();

            // --- View Mode Toggle ---
            const updateViewModeDisplay = () => {
                if (viewMode === 'logs') {
                    logsToggle.classList.add('bg-white', 'dark:bg-gray-600', 'text-gray-900', 'dark:text-gray-100', 'shadow-sm');
                    logsToggle.classList.remove('text-gray-600', 'dark:text-gray-400');
                    eventsToggle.classList.remove('bg-white', 'dark:bg-gray-600', 'text-gray-900', 'dark:text-gray-100', 'shadow-sm');
                    eventsToggle.classList.add('text-gray-600', 'dark:text-gray-400');
                    selectorLabel.textContent = 'Pod';
                } else {
                    eventsToggle.classList.add('bg-white', 'dark:bg-gray-600', 'text-gray-900', 'dark:text-gray-100', 'shadow-sm');
                    eventsToggle.classList.remove('text-gray-600', 'dark:text-gray-400');
                    logsToggle.classList.remove('bg-white', 'dark:bg-gray-600', 'text-gray-900', 'dark:text-gray-100', 'shadow-sm');
                    logsToggle.classList.add('text-gray-600', 'dark:text-gray-400');
                    selectorLabel.textContent = 'Object';
                }
                updateUIElementsForViewMode();
            };

            logsToggle.addEventListener('click', () => {
                if (viewMode !== 'logs') {
                    const previousSelection = podSelector.value; // Store current selection
                    viewMode = 'logs';
                    localStorage.setItem('viewMode', viewMode);
                    updateViewModeDisplay();
                    // Only refresh if we're switching from events - optimize data fetching
                    fetchPodsAndRestoreSelection(previousSelection);
                }
            });

            eventsToggle.addEventListener('click', () => {
                if (viewMode !== 'events') {
                    const previousSelection = podSelector.value; // Store current selection
                    viewMode = 'events';
                    localStorage.setItem('viewMode', viewMode);
                    updateViewModeDisplay();
                    // For events view, default to "all" objects and fetch event sources
                    fetchEventSourcesAndRestoreSelection('all');
                }
            });

            // Initialize view mode
            updateViewModeDisplay();
            updateUIElementsForViewMode();

            // --- API Calls ---
            async function fetchFromServer(endpoint, options = {}) {
                errorDisplay.textContent = '';
                try {
                    const url = new URL(endpoint, window.location.href);

                    // Extract API key from current page URL and add to API requests
                    const currentUrlParams = new URLSearchParams(window.location.search);
                    const apiKey = currentUrlParams.get('api_key');
                    if (apiKey) {
                        url.searchParams.set('api_key', apiKey);
                    }

                    // Ensure Accept header is set for all API requests to get JSON responses
                    const defaultHeaders = {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json',
                        ...options.headers
                    };

                    const response = await fetch(url.href, {
                        ...options,
                        headers: defaultHeaders
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({
                            message: `HTTP error! status: ${response.status} on ${url.href}`,
                            error_type: 'http_error',
                            retry_suggested: response.status >= 500 || response.status === 429
                        }));

                        // Enhanced error with metadata
                        const enhancedError = new Error(errorData.message || `HTTP error! status: ${response.status} on ${url.href}`);
                        enhancedError.errorType = errorData.error_type || 'http_error';
                        enhancedError.retrySuggested = errorData.retry_suggested || false;
                        enhancedError.statusCode = response.status;
                        enhancedError.endpoint = endpoint;
                        throw enhancedError;
                    }
                    return await response.json();
                } catch (error) {
                    console.error(`Error fetching ${endpoint} (resolved to ${url.href}):`, error);

                    // Enhanced error display with retry suggestion
                    let errorMessage = `Error: ${error.message}`;
                    if (error.retrySuggested) {
                        errorMessage += ' (Retry recommended)';
                    }
                    errorDisplay.textContent = errorMessage;

                    throw error;
                }
            }

            function formatTimestamp(timestamp) {
                if (!timestamp) return '-';
                try {
                    const date = new Date(timestamp);
                    const now = new Date();
                    const diffMs = now - date;
                    const diffMinutes = Math.floor(diffMs / 60000);
                    const diffHours = Math.floor(diffMinutes / 60);
                    const diffDays = Math.floor(diffHours / 24);

                    if (diffMinutes < 1) {
                        return 'Just now';
                    } else if (diffMinutes < 60) {
                        return `${diffMinutes}m ago`;
                    } else if (diffHours < 24) {
                        return `${diffHours}h ago`;
                    } else if (diffDays < 7) {
                        return `${diffDays}d ago`;
                    } else {
                        return date.toLocaleDateString();
                    }
                } catch (e) {
                    return timestamp.substring(0, 16);
                }
            }

            function getHealthStatusEmoji(status) {
                const statusEmojis = {
                    'healthy': '✅',
                    'partial': '⚠️',
                    'unhealthy': '❌',
                    'pending': '⏳',
                    'waiting': '⏸️',
                    'terminated': '⏹️',
                    'failed': '💥',
                    'succeeded': '✅',
                    'unknown': '❓',
                    'error': '🚨'
                };
                return statusEmojis[status] || '❓';
            }

            function formatOptionText(podInfo, maxPodLength, maxContainerLength) {
                const healthEmoji = getHealthStatusEmoji(podInfo.health_status);
                const timeText = formatTimestamp(podInfo.last_log_time);

                // Split pod and container for separate columns
                let podName, containerName;
                if (podInfo.id.includes('/')) {
                    const parts = podInfo.id.split('/');
                    podName = parts[0];
                    containerName = parts[1];
                } else {
                    podName = podInfo.id;
                    containerName = podInfo.container_name;
                }

                // Add type indicators
                if (podInfo.type === 'init_container') {
                    containerName = `${containerName} [INIT]`;
                } else if (podInfo.type === 'pod' && containerName === podName) {
                    containerName = '-'; // Single container pod
                }

                // Pad both columns for alignment (use fixed width for emojis)
                const paddedPod = podName.padEnd(maxPodLength);
                const paddedContainer = containerName.padEnd(maxContainerLength);

                // Format: Pod | Container | Status | Last Log Time
                return `${paddedPod} | ${paddedContainer} | ${healthEmoji} | ${timeText}`;
            }

            function formatUnifiedOptionText(source, maxPodLength, maxContainerLength, viewMode) {
                let podName, containerName;

                if (source.sourceType === 'event_source') {
                    // For event sources, show Kind/Name format
                    podName = source.pod_name;
                    containerName = source.container_name; // This contains the Kind
                } else {
                    // For pods, use existing logic
                    if (source.id.includes('/')) {
                        const parts = source.id.split('/');
                        podName = parts[0];
                        containerName = parts[1];
                    } else {
                        podName = source.pod_name || source.id;
                        containerName = source.container_name;
                    }

                    // Add type indicators
                    if (source.type === 'init_container') {
                        containerName = `${containerName} [INIT]`;
                    } else if (source.type === 'pod' && containerName === podName) {
                        containerName = '-'; // Single container pod
                    }
                }

                // Determine status emoji/indicator
                let statusEmoji;
                if (source.sourceType === 'event_source') {
                    statusEmoji = source.health_status === 'warning' ? '⚠️' : '📅';
                } else if (source.sourceType === 'archived') {
                    statusEmoji = '📁';
                } else {
                    statusEmoji = getHealthStatusEmoji(source.health_status);
                    // Add indicator if this source has both logs and events
                    if (source.hasLogs && source.hasEvents) {
                        statusEmoji += '📅'; // Add event indicator
                    }
                }

                // Format time
                const timeText = formatTimestamp(source.last_log_time);

                // Pad for alignment
                const paddedPod = podName.padEnd(maxPodLength);
                const paddedContainer = containerName.padEnd(maxContainerLength);

                return `${paddedPod} | ${paddedContainer} | ${statusEmoji} | ${timeText}`;
            }

            function calculateMaxLengths(livePodsData, archivedPodsData, currentPodName) {
                let maxPodLength = 8; // Minimum for "All Pods"
                let maxContainerLength = 9; // Minimum for "Container"

                // Check live pods
                if (livePodsData.pods && livePodsData.pods.length > 0) {
                    livePodsData.pods.forEach(podInfo => {
                        let podName, containerName;
                        if (podInfo.id.includes('/')) {
                            const parts = podInfo.id.split('/');
                            podName = parts[0];
                            containerName = parts[1];
                        } else {
                            podName = podInfo.id;
                            containerName = podInfo.container_name;
                        }

                        // Add type indicators for container length calculation
                        if (podInfo.type === 'init_container') {
                            containerName = `${containerName} [INIT]`;
                        } else if (podInfo.type === 'pod' && containerName === podName) {
                            containerName = '-';
                        }

                        maxPodLength = Math.max(maxPodLength, podName.length);
                        maxContainerLength = Math.max(maxContainerLength, containerName.length);
                    });
                }

                // Check current pod if not in live pods
                if (currentPodName) {
                    maxPodLength = Math.max(maxPodLength, currentPodName.length);
                    maxContainerLength = Math.max(maxContainerLength, '-'.length);
                }

                // Check archived pods
                if (archivedPodsData.archived_pods && archivedPodsData.archived_pods.length > 0) {
                    archivedPodsData.archived_pods.forEach(podName => {
                        maxPodLength = Math.max(maxPodLength, podName.length);
                        maxContainerLength = Math.max(maxContainerLength, '[ARCHIVED]'.length);
                    });
                }

                return { maxPodLength, maxContainerLength };
            }

            function createUnifiedSourceList(livePodsData, eventSourcesData, archivedPodsData, currentPodName) {
                const unifiedSources = [];
                const seenKeys = new Set();

                // Add live pods first
                if (livePodsData.pods && livePodsData.pods.length > 0) {
                    livePodsData.pods.forEach(podInfo => {
                        const key = podInfo.id;
                        if (!seenKeys.has(key)) {
                            unifiedSources.push({
                                ...podInfo,
                                sourceType: 'pod',
                                hasLogs: true,
                                hasEvents: false // Will be updated if found in events
                            });
                            seenKeys.add(key);
                        }
                    });
                }

                // Add current pod if not in live pods and excludeSelf is unchecked
                if (!excludeSelf.checked && currentPodName && !seenKeys.has(currentPodName)) {
                    unifiedSources.push({
                        id: currentPodName,
                        pod_name: currentPodName,
                        container_name: currentPodName,
                        type: 'pod',
                        health_status: 'unknown',
                        health_reason: 'Current pod (limited info available)',
                        last_log_time: null,
                        created_time: null,
                        sourceType: 'pod',
                        hasLogs: true,
                        hasEvents: false
                    });
                    seenKeys.add(currentPodName);
                }

                // Add event sources and mark existing pods as having events
                if (eventSourcesData.sources && eventSourcesData.sources.length > 0) {
                    eventSourcesData.sources.forEach(source => {
                        const podKey = source.object_name; // Try to match by pod name
                        const fullKey = source.id; // Full "Kind/Name" format

                        // Check if this is a pod we already have
                        let existingPod = unifiedSources.find(s =>
                            s.pod_name === source.object_name ||
                            s.id === source.object_name ||
                            s.id.includes(source.object_name)
                        );

                        if (existingPod) {
                            // Mark existing pod as having events
                            existingPod.hasEvents = true;
                            existingPod.eventInfo = source;
                        } else if (!seenKeys.has(fullKey)) {
                            // Add as new event-only source
                            unifiedSources.push({
                                id: fullKey,
                                pod_name: source.object_name,
                                container_name: `${source.object_kind}`,
                                type: 'event_source',
                                health_status: source.latest_event_type === 'Warning' ? 'warning' : 'normal',
                                health_reason: `${source.event_count} events`,
                                last_log_time: source.latest_timestamp,
                                created_time: null,
                                sourceType: 'event_source',
                                hasLogs: false,
                                hasEvents: true,
                                eventInfo: source
                            });
                            seenKeys.add(fullKey);
                        }
                    });
                }

                // Add archived pods
                if (archivedPodsData.archived_pods && archivedPodsData.archived_pods.length > 0) {
                    const livePodNames = new Set(livePodsData.pods?.map(p => p.id) || []);
                    const filteredArchivedPods = archivedPodsData.archived_pods.filter(
                        podName => !livePodNames.has(podName) && !seenKeys.has(`archived:${podName}`)
                    );

                    filteredArchivedPods.forEach(podName => {
                        const archivedKey = `archived:${podName}`;
                        unifiedSources.push({
                            id: archivedKey,
                            pod_name: podName,
                            container_name: '[ARCHIVED]',
                            type: 'archived',
                            health_status: 'archived',
                            health_reason: 'Archived pod logs',
                            last_log_time: null,
                            created_time: null,
                            sourceType: 'archived',
                            hasLogs: true,
                            hasEvents: false
                        });
                        seenKeys.add(archivedKey);
                    });
                }

                return unifiedSources;
            }

            function calculateMaxLengthsUnified(unifiedSources) {
                let maxPodLength = 8; // Minimum for headers
                let maxContainerLength = 9;

                unifiedSources.forEach(source => {
                    let podName, containerName;
                    if (source.id.includes('/')) {
                        const parts = source.id.split('/');
                        podName = parts[0];
                        containerName = parts[1];
                    } else {
                        podName = source.pod_name || source.id;
                        containerName = source.container_name;
                    }

                    if (source.type === 'init_container') {
                        containerName = `${containerName} [INIT]`;
                    } else if (source.type === 'pod' && containerName === podName) {
                        containerName = '-';
                    }

                    maxPodLength = Math.max(maxPodLength, podName.length);
                    maxContainerLength = Math.max(maxContainerLength, containerName.length);
                });

                return { maxPodLength, maxContainerLength };
            }

            async function fetchEventSources() {
                try {
                    // Store current selection before refresh
                    const currentSelection = podSelector.value;

                    const eventSourcesData = await fetchFromServer('/api/event_sources');
                    namespaceValue.textContent = eventSourcesData.namespace || 'N/A';

                    // Calculate maximum lengths for alignment
                    let maxObjectLength = 15; // Minimum for "All Objects"
                    let maxKindLength = 10; // Minimum for "Kind"

                    if (eventSourcesData.sources && eventSourcesData.sources.length > 0) {
                        eventSourcesData.sources.forEach(source => {
                            maxObjectLength = Math.max(maxObjectLength, source.object_name.length);
                            maxKindLength = Math.max(maxKindLength, source.object_kind.length);
                        });
                    }

                    // Create aligned header
                    const headerObject = "Object".padEnd(maxObjectLength);
                    const headerKind = "Kind".padEnd(maxKindLength);

                    // Reset selector with aligned header and "All Objects" option
                    const allObjectsName = "All Objects".padEnd(maxObjectLength);
                    const allObjectsKind = "-".padEnd(maxKindLength);
                    podSelector.innerHTML = `
                        <option value="" disabled style="font-weight: bold; color: #6b7280; background-color: #f9fafb;">── ${headerObject} | ${headerKind} | Events | Last Event ──</option>
                        <option value="all">${allObjectsName} | ${allObjectsKind} | 📅 | -</option>
                    `;

                    if (eventSourcesData.sources && eventSourcesData.sources.length > 0) {
                        const sourcesGroup = document.createElement('optgroup');
                        sourcesGroup.label = "Event Sources";

                        eventSourcesData.sources.forEach(source => {
                            const paddedName = source.object_name.padEnd(maxObjectLength);
                            const paddedKind = source.object_kind.padEnd(maxKindLength);
                            const eventEmoji = source.latest_event_type === 'Warning' ? '⚠️' : '📅';
                            const timeText = formatTimestamp(source.latest_timestamp);

                            const option = document.createElement('option');
                            option.value = source.id;
                            option.textContent = `${paddedName} | ${paddedKind} | ${eventEmoji} | ${timeText}`;
                            option.title = `${source.object_kind}/${source.object_name} - ${source.event_count} events`;
                            sourcesGroup.appendChild(option);
                        });

                        podSelector.appendChild(sourcesGroup);
                    } else {
                        const noSourcesText = "No event sources found".padEnd(maxObjectLength);
                        const noSourcesKind = "-".padEnd(maxKindLength);
                        podSelector.innerHTML = `
                            <option value="" disabled style="font-weight: bold; color: #6b7280; background-color: #f9fafb;">── ${headerObject} | ${headerKind} | Events | Last Event ──</option>
                            <option value="all">${noSourcesText} | ${noSourcesKind} | ❌ | -</option>
                        `;
                    }

                    // Try to restore previous selection
                    if (currentSelection) {
                        const optionExists = Array.from(podSelector.options).some(option => option.value === currentSelection);
                        if (optionExists) {
                            podSelector.value = currentSelection;
                        } else {
                            podSelector.value = "all";
                        }
                    } else {
                        podSelector.value = "all";
                    }

                    // Refresh data for the current selection
                    fetchAndDisplayData();
                } catch (error) {
                    namespaceValue.textContent = 'Error loading';
                    errorDisplay.textContent = `Error fetching event sources: ${error.message}`;

                    const defaultMaxObjectLength = 15;
                    const defaultMaxKindLength = 10;
                    const headerObject = "Object".padEnd(defaultMaxObjectLength);
                    const headerKind = "Kind".padEnd(defaultMaxKindLength);
                    const errorText = "Error loading".padEnd(defaultMaxObjectLength);
                    const errorKind = "-".padEnd(defaultMaxKindLength);
                    podSelector.innerHTML = `
                        <option value="" disabled style="font-weight: bold; color: #6b7280; background-color: #f9fafb;">── ${headerObject} | ${headerKind} | Events | Last Event ──</option>
                        <option value="all">${errorText} | ${errorKind} | ❌ | -</option>
                    `;
                }
            }

            // Helper function to find the best matching selection when switching views
            function findBestMatch(previousSelection, availableOptions) {
                if (!previousSelection || previousSelection === 'all') {
                    return 'all';
                }

                // Try exact match first
                for (const option of availableOptions) {
                    if (option.value === previousSelection) {
                        return previousSelection;
                    }
                }

                // For logs->events: try to match pod name to object name
                // For events->logs: try to match object name to pod name
                let extractedName = '';
                if (previousSelection.includes('/')) {
                    // Extract the object/pod name part
                    const parts = previousSelection.split('/');
                    extractedName = parts[parts.length - 1]; // Get the last part (name)
                }

                // Try to find a partial match
                for (const option of availableOptions) {
                    if (option.value === 'all' || !option.value) continue;

                    // Check if the extracted name appears in this option
                    if (extractedName && option.value.includes(extractedName)) {
                        return option.value;
                    }

                    // Check if any part of the previous selection matches
                    if (option.value.includes(previousSelection) || previousSelection.includes(option.value)) {
                        return option.value;
                    }
                }

                // Fallback to 'all' if no match found
                return 'all';
            }

            async function fetchPodsAndRestoreSelection(previousSelection) {
                try {
                    await fetchUnifiedSources();

                    // Try to restore or find best match for the selection
                    const bestMatch = findBestMatch(previousSelection, Array.from(podSelector.options));
                    podSelector.value = bestMatch;

                    // Trigger data fetch for the restored selection
                    fetchAndDisplayData();
                } catch (error) {
                    console.error('Error in fetchPodsAndRestoreSelection:', error);
                }
            }

            async function fetchEventSourcesAndRestoreSelection(previousSelection) {
                try {
                    await fetchUnifiedSources();

                    // Try to restore or find best match for the selection
                    const bestMatch = findBestMatch(previousSelection, Array.from(podSelector.options));
                    podSelector.value = bestMatch;

                    // Trigger data fetch for the restored selection
                    fetchAndDisplayData();
                } catch (error) {
                    console.error('Error in fetchEventSourcesAndRestoreSelection:', error);
                }
            }

            // Keep the old functions for backward compatibility but make them call the unified function
            async function fetchPods() {
                return fetchUnifiedSources();
            }

            async function fetchEventSources() {
                return fetchUnifiedSources();
            }

            async function fetchUnifiedSources() {
                try {
                    // Store current selection before refresh
                    const currentSelection = podSelector.value;

                    // Optimize API calls based on view mode
                    const params = new URLSearchParams();
                    if (excludeSelf.checked) {
                        params.append('exclude_self', 'true');
                    }

                    let livePodsData, eventSourcesData;

                    if (viewMode === 'logs') {
                        // For logs view, we primarily need pods data
                        // Only fetch event sources if we need unified view
                        const [podsResult, eventsResult] = await Promise.all([
                            fetchFromServer(`/api/pods?${params.toString()}`),
                            fetchFromServer('/api/event_sources')
                        ]);
                        livePodsData = podsResult;
                        eventSourcesData = eventsResult;
                    } else {
                        // For events view, we primarily need event sources
                        // Still fetch pods for context but prioritize events
                        const [eventsResult, podsResult] = await Promise.all([
                            fetchFromServer('/api/event_sources'),
                            fetchFromServer(`/api/pods?${params.toString()}`)
                        ]);
                        livePodsData = podsResult;
                        eventSourcesData = eventsResult;
                    }

                    namespaceValue.textContent = livePodsData.namespace || eventSourcesData.namespace || 'N/A';
                    currentPodName = livePodsData.current_pod || null;

                    // Fetch archived pods
                    let archivedPodsData = { archived_pods: [] };
                    try {
                        archivedPodsData = await fetchFromServer('/api/archived_pods');
                    } catch (error) {
                        console.warn("Could not fetch archived pods, possibly disabled:", error.message);
                    }

                    if (viewMode === 'events') {
                        // For events view, show only event sources
                        await populateEventSourcesSelector(eventSourcesData);
                    } else {
                        // For logs view, show unified sources (pods + events + archived)
                        const unifiedSources = createUnifiedSourceList(livePodsData, eventSourcesData, archivedPodsData, currentPodName);
                        await populateUnifiedSourcesSelector(unifiedSources);
                    }

                    // Selection restoration is handled within the populate functions
                } catch (error) {
                    // Handle errors for both view modes
                    namespaceValue.textContent = 'Error loading';
                    errorDisplay.textContent = `Error fetching ${viewMode === 'events' ? 'event sources' : 'pod list'}: ${error.message}`;

                    // Use default padding for error case
                    if (viewMode === 'events') {
                        const defaultMaxObjectLength = 15;
                        const defaultMaxKindLength = 10;
                        const headerObject = "Object".padEnd(defaultMaxObjectLength);
                        const headerKind = "Kind".padEnd(defaultMaxKindLength);
                        const errorText = "Error loading".padEnd(defaultMaxObjectLength);
                        const errorKind = "-".padEnd(defaultMaxKindLength);
                        podSelector.innerHTML = `
                            <option value="" disabled style="font-weight: bold; color: #6b7280; background-color: #f9fafb;">── ${headerObject} | ${headerKind} | Events | Last Event ──</option>
                            <option value="all">${errorText} | ${errorKind} | ❌ | -</option>
                        `;
                    } else {
                        const defaultMaxPodLength = 15;
                        const defaultMaxContainerLength = 10;
                        const headerPod = "Pod".padEnd(defaultMaxPodLength);
                        const headerContainer = "Container".padEnd(defaultMaxContainerLength);
                        const errorText = "Error loading".padEnd(defaultMaxPodLength);
                        const errorContainer = "-".padEnd(defaultMaxContainerLength);
                        podSelector.innerHTML = `
                            <option value="" disabled style="font-weight: bold; color: #6b7280; background-color: #f9fafb;">── ${headerPod} | ${headerContainer} | Status | Last Log ──</option>
                            <option value="all">${errorText} | ${errorContainer} | ❌ | -</option>
                        `;
                    }
                }
            }

            // Helper function to populate event sources selector
            async function populateEventSourcesSelector(eventSourcesData) {
                // Calculate maximum lengths for alignment
                let maxObjectLength = 15; // Minimum for "All Objects"
                let maxKindLength = 10; // Minimum for "Kind"

                if (eventSourcesData.sources && eventSourcesData.sources.length > 0) {
                    eventSourcesData.sources.forEach(source => {
                        maxObjectLength = Math.max(maxObjectLength, source.object_name.length);
                        maxKindLength = Math.max(maxKindLength, source.object_kind.length);
                    });
                }

                // Create aligned header
                const headerObject = "Object".padEnd(maxObjectLength);
                const headerKind = "Kind".padEnd(maxKindLength);

                // Reset selector with aligned header and "All Objects" option
                const allObjectsName = "All Objects".padEnd(maxObjectLength);
                const allObjectsKind = "-".padEnd(maxKindLength);
                podSelector.innerHTML = `
                    <option value="" disabled style="font-weight: bold; color: #6b7280; background-color: #f9fafb;">── ${headerObject} | ${headerKind} | Events | Last Event ──</option>
                    <option value="all">${allObjectsName} | ${allObjectsKind} | 📅 | -</option>
                `;

                if (eventSourcesData.sources && eventSourcesData.sources.length > 0) {
                    const sourcesGroup = document.createElement('optgroup');
                    sourcesGroup.label = "Event Sources";

                    eventSourcesData.sources.forEach(source => {
                        const paddedName = source.object_name.padEnd(maxObjectLength);
                        const paddedKind = source.object_kind.padEnd(maxKindLength);
                        const eventEmoji = source.latest_event_type === 'Warning' ? '⚠️' : '📅';
                        const timeText = formatTimestamp(source.latest_timestamp);

                        const option = document.createElement('option');
                        option.value = source.id;
                        option.textContent = `${paddedName} | ${paddedKind} | ${eventEmoji} | ${timeText}`;
                        option.title = `${source.object_kind}/${source.object_name} - ${source.event_count} events`;
                        sourcesGroup.appendChild(option);
                    });

                    podSelector.appendChild(sourcesGroup);
                }

                // Always default to "all" for events view
                podSelector.value = "all";
                fetchAndDisplayData();
            }

            // Helper function to populate unified sources selector for logs view
            async function populateUnifiedSourcesSelector(unifiedSources) {
                // Calculate maximum lengths for alignment
                const { maxPodLength, maxContainerLength } = calculateMaxLengthsUnified(unifiedSources);

                // Create aligned header
                const headerPod = "Pod".padEnd(maxPodLength);
                const headerContainer = "Container".padEnd(maxContainerLength);

                // Reset selector with aligned header and "All Pods" option
                const allPadded = "All Pods".padEnd(maxPodLength);
                const allContainerPadded = "-".padEnd(maxContainerLength);

                podSelector.innerHTML = `
                    <option value="" disabled style="font-weight: bold; color: #6b7280; background-color: #f9fafb;">── ${headerPod} | ${headerContainer} | Status | Last Log ──</option>
                    <option value="all">${allPadded} | ${allContainerPadded} | 🌐 | -</option>
                `;

                const createOption = (value, text, isArchived = false, sourceInfo = null) => {
                    const option = document.createElement('option');
                    option.value = isArchived ? `archived:${value}` : value;
                    option.textContent = text;
                    if (isArchived) {
                        option.dataset.isArchived = "true";
                    }
                    if (sourceInfo) {
                        option.dataset.hasLogs = sourceInfo.hasLogs;
                        option.dataset.hasEvents = sourceInfo.hasEvents;
                        option.dataset.sourceType = sourceInfo.sourceType;
                    }
                    return option;
                };

                // Render unified sources
                if (unifiedSources.length > 0) {
                    // Group sources by type
                    const liveSourcesWithLogs = unifiedSources.filter(s => s.hasLogs && s.sourceType !== 'archived');
                    const archivedSources = unifiedSources.filter(s => s.sourceType === 'archived');

                    // Add live sources with logs
                    if (liveSourcesWithLogs.length > 0) {
                        const liveGroup = document.createElement('optgroup');
                        liveGroup.label = "Live Pods";

                        liveSourcesWithLogs.sort((a, b) => a.id.localeCompare(b.id)).forEach(source => {
                            const optionText = formatUnifiedOptionText(source, maxPodLength, maxContainerLength, 'logs');
                            const option = createOption(source.id, optionText, false, source);

                            // Create tooltip based on what data is available
                            let tooltipParts = [];
                            if (source.hasLogs) tooltipParts.push('Has logs');
                            if (source.hasEvents) tooltipParts.push(`${source.eventInfo?.event_count || 'some'} events`);
                            if (source.health_reason) tooltipParts.push(source.health_reason);
                            if (source.created_time) tooltipParts.push(`Created: ${new Date(source.created_time).toLocaleString()}`);

                            option.title = tooltipParts.join(' | ') || 'No additional info';
                            liveGroup.appendChild(option);
                        });

                        podSelector.appendChild(liveGroup);
                    }

                    // Add archived sources
                    if (archivedSources.length > 0) {
                        const archivedGroup = document.createElement('optgroup');
                        archivedGroup.label = "Previous Pods";

                        archivedSources.sort((a, b) => a.id.localeCompare(b.id)).forEach(source => {
                            const optionText = formatUnifiedOptionText(source, maxPodLength, maxContainerLength, 'logs');
                            const option = createOption(source.pod_name, optionText, true, source);
                            option.title = "Archived pod logs";
                            archivedGroup.appendChild(option);
                        });

                        podSelector.appendChild(archivedGroup);
                    }
                } else {
                    const noItemsText = "No pods found".padEnd(maxPodLength);
                    const noItemsContainer = "-".padEnd(maxContainerLength);
                    podSelector.innerHTML += `<option value="none">${noItemsText} | ${noItemsContainer} | ❌ | -</option>`;
                }

                // Try to restore selection or default to "all"
                const currentSelection = podSelector.value;
                if (!currentSelection || currentSelection === '') {
                    podSelector.value = "all";
                }
                fetchAndDisplayData();
            }

            async function fetchAndDisplayData() {
                if (viewMode === 'logs') {
                    return fetchAndDisplayLogs();
                } else {
                    return fetchAndDisplayEvents();
                }
            }

            async function fetchAndDisplayEvents() {
                const selectedOption = podSelector.options[podSelector.selectedIndex];
                if (!selectedOption || !selectedOption.value) {
                    logOutput.textContent = 'Please select an object to view events.';
                    currentEvents = [];
                    return;
                }

                const selectedValue = selectedOption.value;
                loadingIndicator.classList.remove('hidden');
                logOutput.textContent = '';

                const params = new URLSearchParams({
                    sort_order: sortOrder.value,
                    limit: numLines.value,
                    search_string: searchBox.value.trim(),
                    case_sensitive: caseSensitive.toString(),
                    exclude_self: excludeSelf.checked.toString(),
                });

                // Parse object selection for events
                if (selectedValue !== 'all') {
                    const [objectKind, objectName] = selectedValue.split('/');
                    if (objectKind && objectName) {
                        params.append('object_kind', objectKind);
                        params.append('object_name', objectName);
                    }
                }

                try {
                    console.log('Fetching events with params:', params.toString());
                    const data = await fetchFromServer(`/api/events?${params.toString()}`);
                    console.log('Received event data:', data);
                    if (!data.events) {
                        console.error('No events array in response:', data);
                        throw new Error('Invalid response format: missing events array');
                    }
                    currentEvents = data.events;
                    currentLogs = []; // Clear logs when viewing events
                    console.log('Setting currentEvents, length:', currentEvents.length);
                    renderEvents();
                } catch (error) {
                    console.error('Error in fetchAndDisplayEvents:', error);
                    currentEvents = [];

                    let errorMessage = `Error loading events: ${error.message}`;
                    if (error.retrySuggested) {
                        errorMessage += ' (Retry recommended)';
                    }
                    errorDisplay.textContent = errorMessage;

                    const errorEventEntry = {
                        error: true,
                        message: error.message,
                        error_type: error.errorType || 'unknown_error',
                        retry_suggested: error.retrySuggested !== false,
                        last_timestamp: null,
                        involved_object_name: selectedValue || 'unknown'
                    };

                    currentEvents = [errorEventEntry];
                    renderEvents();
                } finally {
                    loadingIndicator.classList.add('hidden');
                }
            }
            async function fetchAndDisplayLogs() {
                const selectedOption = podSelector.options[podSelector.selectedIndex];
                if (!selectedOption || !selectedOption.value) {
                    logOutput.textContent = 'Please select a pod to view logs.';
                    currentLogs = [];
                    return;
                }

                const selectedValue = selectedOption.value;
                const isArchivedLog = selectedOption.dataset.isArchived === "true";
                const actualPodName = isArchivedLog ? selectedValue.substring("archived:".length) : selectedValue;

                loadingIndicator.classList.remove('hidden');
                logOutput.textContent = '';

                const params = new URLSearchParams({
                    pod_name: actualPodName,
                    sort_order: sortOrder.value,
                    tail_lines: numLines.value,
                    search_string: searchBox.value.trim(),
                    case_sensitive: caseSensitive.toString(),
                });

                // Add exclude_self parameter if needed
                if (excludeSelf.checked && currentPodName) {
                    params.append('exclude_self', currentPodName);
                }

                const apiEndpoint = isArchivedLog ? '/api/archived_logs' : '/api/logs';

                try {
                    // Enhanced fetch with session continuity and client-side buffering
                    console.log('Fetching logs with params:', params.toString());
                    const data = await fetchFromServer(`${apiEndpoint}?${params.toString()}`);
                    console.log('Received log data:', data);
                    
                    if (!data.logs) {
                        console.error('No logs array in response:', data);
                        throw new Error('Invalid response format: missing logs array');
                    }

                    // Update session ID from server
                    if (data.session_id) {
                        logSessionId = data.session_id;
                        console.log('Updated session ID:', logSessionId);
                    }

                    // Add new logs to buffer (with deduplication)
                    const containerKey = actualPodName;
                    const addedCount = addLogsToBuffer(containerKey, data.logs);
                    
                    // Get buffered logs for this container (or all if viewing "all")
                    if (actualPodName === 'all') {
                        currentLogs = getBufferedLogs(); // Get all buffered logs
                    } else {
                        currentLogs = getBufferedLogs(containerKey);
                    }
                    
                    currentEvents = []; // Clear events when viewing logs
                    console.log(`Setting currentLogs, total length: ${currentLogs.length}, new logs: ${addedCount}`);
                    renderLogs();
                } catch (error) {
                    console.error('Error in fetchAndDisplayLogs:', error);
                    currentLogs = [];

                    // Create a detailed error message
                    let errorMessage = `Error loading logs: ${error.message}`;
                    if (error.retrySuggested) {
                        errorMessage += ' (Retry recommended)';
                    }
                    errorDisplay.textContent = errorMessage;

                    // Create an error log entry for display
                    const errorLogEntry = {
                        error: true,
                        message: error.message,
                        error_type: error.errorType || 'unknown_error',
                        retry_suggested: error.retrySuggested !== false,
                        timestamp: null,
                        pod_name: actualPodName || 'unknown',
                        line_id: `error:${Date.now()}:${Math.random()}`
                    };

                    currentLogs = [errorLogEntry];
                    renderLogs();
                } finally {
                    loadingIndicator.classList.add('hidden');
                }
            }

            // --- Log Rendering ---
            function renderLogs() {
                console.log('Starting renderLogs, currentLogs length:', currentLogs.length);
                logOutput.innerHTML = '';

                if (!Array.isArray(currentLogs)) {
                    console.error('currentLogs is not an array:', currentLogs);
                    errorDisplay.textContent = 'Error: Invalid log data format';
                    return;
                }

                if (currentLogs.length === 0) {
                    logOutput.textContent = 'No logs to display for the current selection.';
                    if (searchBox.value.trim() && podSelector.value) {
                         logOutput.textContent += `\nOr no logs match your search term: "${searchBox.value.trim()}"`;
                    }
                    return;
                }

                const fragment = document.createDocumentFragment();
                const searchTerm = searchBox.value.trim(); // For search highlighting

                // Use shared pod colors and color mapping
                const { podColorMap, updateColorIndex } = getOrCreateColorMapping();
                let colorIndex = globalColorIndex;

                const logColoringRules = {
                    error: {
                        terms: ['error', 'err', 'fatal', 'panic', 'exception', 'critical', 'failed', 'failure'],
                        classes: ['text-red-600', 'dark:text-red-400', 'font-semibold']
                    },
                    warning: {
                        terms: ['warning', 'warn', 'wrn'],
                        classes: ['text-orange-500', 'dark:text-orange-400']
                    },
                    info: {
                        terms: ['info', 'notice', 'inf'],
                        classes: ['text-green-600', 'dark:text-green-400']
                    },
                    debug: {
                        terms: ['debug', 'dbg', 'trace', 'trc'],
                        classes: ['text-cyan-600', 'dark:text-cyan-400']
                    }
                };

                currentLogs.forEach(logEntry => {
                    const lineDiv = document.createElement('div');
                    lineDiv.classList.add('log-line', 'py-0.5');

                    // Handle error entries specially
                    if (logEntry.error) {
                        lineDiv.classList.add('log-error');
                        const errorDiv = document.createElement('div');
                        errorDiv.innerHTML = logEntry.message || 'Unknown error';

                        // Add retry button if retry is suggested
                        if (logEntry.retry_suggested !== false) {
                            const retryButton = document.createElement('button');
                            retryButton.textContent = 'Retry';
                            retryButton.className = 'retry-button';
                            retryButton.onclick = () => fetchAndDisplayLogs();
                            errorDiv.appendChild(retryButton);
                        }

                        lineDiv.appendChild(errorDiv);
                        fragment.appendChild(lineDiv);
                        return;
                    }

                    // Assign color to pod if viewing all pods
                    if (podSelector.value === 'all' && logEntry.pod_name) {
                        if (!podColorMap.has(logEntry.pod_name)) {
                            podColorMap.set(logEntry.pod_name, podColors[colorIndex % podColors.length]);
                            colorIndex++;
                        }
                        const podColor = podColorMap.get(logEntry.pod_name);

                        const podSpan = document.createElement('span');
                        podSpan.classList.add('mr-3', 'font-medium', ...podColor);
                        podSpan.textContent = `[${logEntry.pod_name}] `;
                        lineDiv.appendChild(podSpan);
                    }

                    const timestampSpan = document.createElement('span');
                    timestampSpan.classList.add('mr-3', 'text-gray-500', 'dark:text-gray-400', 'select-none');
                    timestampSpan.textContent = formatTimestamp(logEntry.timestamp) + ' ';

                    const messageSpan = document.createElement('span');
                    messageSpan.classList.add('log-message');

                    let messageContent = logEntry.message; // Original message content

                    // Apply keyword coloring first
                    let coloredMessageContent = messageContent;
                    const levelsInOrder = ['error', 'warning', 'info']; // Process in this order

                    for (const level of levelsInOrder) {
                        const rule = logColoringRules[level];
                        if (rule) {
                            for (const term of rule.terms) {
                                // Regex for whole word, case-insensitive
                                // \b ensures "word boundary"
                                const termRegex = new RegExp(`\\b(${escapeRegExp(term)})\\b`, 'gi');
                                coloredMessageContent = coloredMessageContent.replace(termRegex, (match) => {
                                    return `<span class="${rule.classes.join(' ')}">${match}</span>`;
                                });
                            }
                        }
                    }

                    // Apply search highlighting on the potentially colorized message
                    if (searchTerm && highlightEnabled) {
                        const searchFlags = caseSensitive ? 'g' : 'gi';
                        const searchRegex = new RegExp(`(${escapeRegExp(searchTerm)})`, searchFlags);
                        coloredMessageContent = coloredMessageContent.replace(searchRegex, (match, p1) => {
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = coloredMessageContent;
                            if (tempDiv.textContent.includes(match)) {
                                return `<mark>${p1}</mark>`;
                            }
                            return match;
                        });
                    }

                    messageSpan.innerHTML = coloredMessageContent;

                    lineDiv.appendChild(timestampSpan);
                    lineDiv.appendChild(messageSpan);
                    fragment.appendChild(lineDiv);
                });
                logOutput.appendChild(fragment);
            }

            // --- Events Rendering ---
            function renderEvents() {
                console.log('Starting renderEvents, currentEvents length:', currentEvents.length);
                logOutput.innerHTML = '';

                if (!Array.isArray(currentEvents)) {
                    console.error('currentEvents is not an array:', currentEvents);
                    errorDisplay.textContent = 'Error: Invalid event data format';
                    return;
                }

                if (currentEvents.length === 0) {
                    logOutput.textContent = 'No events to display for the current selection.';
                    if (searchBox.value.trim() && podSelector.value) {
                         logOutput.textContent += `\nOr no events match your search term: "${searchBox.value.trim()}"`;
                    }
                    return;
                }

                const fragment = document.createDocumentFragment();
                const searchTerm = searchBox.value.trim();

                // Use shared pod colors and color mapping
                const { podColorMap, updateColorIndex } = getOrCreateColorMapping();
                let colorIndex = globalColorIndex;

                // Define event type colors
                const eventTypeColors = {
                    'Warning': ['text-orange-600', 'dark:text-orange-400'],
                    'Normal': ['text-blue-600', 'dark:text-blue-400'],
                };

                // Define event reason colors
                const eventReasonColors = {
                    'error': ['text-red-600', 'dark:text-red-400', 'font-semibold'],
                    'failed': ['text-red-600', 'dark:text-red-400', 'font-semibold'],
                    'killing': ['text-red-600', 'dark:text-red-400'],
                    'created': ['text-green-600', 'dark:text-green-400'],
                    'started': ['text-green-600', 'dark:text-green-400'],
                    'pulled': ['text-green-600', 'dark:text-green-400'],
                    'scheduled': ['text-blue-600', 'dark:text-blue-400'],
                };

                currentEvents.forEach(eventEntry => {
                    const lineDiv = document.createElement('div');
                    lineDiv.classList.add('log-line', 'py-0.5');

                    // Handle error entries specially
                    if (eventEntry.error) {
                        lineDiv.classList.add('log-error');
                        const errorDiv = document.createElement('div');
                        errorDiv.innerHTML = eventEntry.message || 'Unknown error';

                        if (eventEntry.retry_suggested !== false) {
                            const retryButton = document.createElement('button');
                            retryButton.textContent = 'Retry';
                            retryButton.className = 'retry-button';
                            retryButton.onclick = () => fetchAndDisplayData();
                            errorDiv.appendChild(retryButton);
                        }

                        lineDiv.appendChild(errorDiv);
                        fragment.appendChild(lineDiv);
                        return;
                    }

                    // Event timestamp
                    const timestampSpan = document.createElement('span');
                    timestampSpan.classList.add('mr-3', 'text-gray-500', 'dark:text-gray-400', 'select-none');
                    timestampSpan.textContent = formatTimestamp(eventEntry.last_timestamp || eventEntry.first_timestamp) + ' ';

                    // Event type with color coding
                    const typeSpan = document.createElement('span');
                    const typeColors = eventTypeColors[eventEntry.type] || ['text-gray-600', 'dark:text-gray-400'];
                    typeSpan.classList.add('mr-2', 'font-medium', ...typeColors);
                    typeSpan.textContent = `[${eventEntry.type || 'Unknown'}]`;

                    // Event reason with color coding
                    const reasonSpan = document.createElement('span');
                    const reasonLower = (eventEntry.reason || '').toLowerCase();
                    let reasonColors = ['text-gray-700', 'dark:text-gray-300'];

                    for (const [keyword, colors] of Object.entries(eventReasonColors)) {
                        if (reasonLower.includes(keyword)) {
                            reasonColors = colors;
                            break;
                        }
                    }

                    reasonSpan.classList.add('mr-2', 'font-medium', ...reasonColors);
                    reasonSpan.textContent = `${eventEntry.reason || 'Unknown'}:`;

                    // Object info (if viewing all events) - with unique colors per object
                    if (podSelector.value === 'all' && eventEntry.involved_object_kind && eventEntry.involved_object_name) {
                        const objectKey = `${eventEntry.involved_object_kind}/${eventEntry.involved_object_name}`;

                        // Use the same color mapping logic as logs
                        if (!podColorMap.has(objectKey)) {
                            podColorMap.set(objectKey, podColors[colorIndex % podColors.length]);
                            colorIndex++;
                        }
                        const objectColor = podColorMap.get(objectKey);

                        const objectSpan = document.createElement('span');
                        objectSpan.classList.add('mr-2', 'font-medium', ...objectColor);
                        objectSpan.textContent = objectKey;
                        lineDiv.appendChild(objectSpan);
                    }

                    // Event message
                    const messageSpan = document.createElement('span');
                    messageSpan.classList.add('event-message');

                    let messageContent = eventEntry.message || 'No message';

                    // Apply search highlighting
                    if (searchTerm && highlightEnabled) {
                        const searchFlags = caseSensitive ? 'g' : 'gi';
                        const searchRegex = new RegExp(`(${escapeRegExp(searchTerm)})`, searchFlags);
                        messageContent = messageContent.replace(searchRegex, '<mark>$1</mark>');
                    }

                    messageSpan.innerHTML = messageContent;

                    lineDiv.appendChild(timestampSpan);
                    lineDiv.appendChild(typeSpan);
                    lineDiv.appendChild(reasonSpan);
                    lineDiv.appendChild(messageSpan);
                    fragment.appendChild(lineDiv);
                });

                logOutput.appendChild(fragment);

                // Update the global color index
                updateColorIndex(colorIndex);
            }

            function escapeRegExp(string) {
                return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }

            // --- Timestamp Formatting ---
            function formatTimestamp(utcTimestamp) {
                if (!utcTimestamp) return "[No Timestamp]";
                const date = new Date(utcTimestamp);
                if (isNaN(date)) return "[Invalid Date]";

                if (timestampType.value === 'utc') {
                    return date.toISOString();
                } else {
                    return timeSince(date);
                }
            }

            function timeSince(date) {
                const seconds = Math.floor((new Date() - date) / 1000);
                let interval = seconds / 31536000;
                if (interval > 1) return Math.floor(interval) + "y ago";
                interval = seconds / 2592000;
                if (interval > 1) return Math.floor(interval) + "mo ago";
                interval = seconds / 86400;
                if (interval > 1) return Math.floor(interval) + "d ago";
                interval = seconds / 3600;
                if (interval > 1) return Math.floor(interval) + "h ago";
                interval = seconds / 60;
                if (interval > 1) return Math.floor(interval) + "m ago";
                if (seconds < 0) return "just now";
                return Math.max(0, Math.floor(seconds)) + "s ago";
            }

            // --- Event Listeners ---
            podSelector.addEventListener('change', () => {
                logOutput.textContent = '';
                currentLogs = [];
                currentEvents = [];
                updateDownloadButtonStates();
                fetchAndDisplayData();
            });
            sortOrder.addEventListener('change', fetchAndDisplayData);
            numLines.addEventListener('change', fetchAndDisplayData);
            timestampType.addEventListener('change', () => {
                if (viewMode === 'logs') {
                    renderLogs();
                } else {
                    renderEvents();
                }
            });

            searchBox.addEventListener('keypress', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    fetchAndDisplayData();
                }
            });

            clearSearch.addEventListener('click', (event) => {
                event.preventDefault();
                searchBox.value = '';
                fetchAndDisplayData();
            });

            refreshPods.addEventListener('click', (event) => {
                event.preventDefault();
                const currentSelection = podSelector.value; // Store current selection
                loadingIndicator.classList.remove('hidden');
                if (viewMode === 'logs') {
                    fetchPodsAndRestoreSelection(currentSelection).finally(() => {
                        loadingIndicator.classList.add('hidden');
                    });
                } else {
                    fetchEventSourcesAndRestoreSelection(currentSelection).finally(() => {
                        loadingIndicator.classList.add('hidden');
                    });
                }
            });

            // Settings menu toggle
            settingsButton.addEventListener('click', (event) => {
                event.stopPropagation();
                settingsMenu.classList.toggle('hidden');
            });

            // Close settings menu when clicking outside
            document.addEventListener('click', (event) => {
                if (!settingsMenu.contains(event.target) && !settingsButton.contains(event.target)) {
                    settingsMenu.classList.add('hidden');
                }
            });

            // Prevent menu from closing when clicking inside it
            settingsMenu.addEventListener('click', (event) => {
                event.stopPropagation();
            });

            // Add event listener for excludeSelf checkbox
            excludeSelf.addEventListener('change', () => {
                const currentSelection = podSelector.value; // Store current selection
                loadingIndicator.classList.remove('hidden');
                if (viewMode === 'logs') {
                    fetchPodsAndRestoreSelection(currentSelection).finally(() => {
                        loadingIndicator.classList.add('hidden');
                    });
                } else {
                    fetchEventSourcesAndRestoreSelection(currentSelection).finally(() => {
                        loadingIndicator.classList.add('hidden');
                    });
                }
            });

            // Download button event listeners
            downloadCurrentLog.addEventListener('click', async (event) => {
                event.preventDefault();
                await downloadSelectedLog();
            });

            downloadPodLogs.addEventListener('click', async (event) => {
                event.preventDefault();
                await downloadPodLogsZip();
            });

            downloadAllLogs.addEventListener('click', async (event) => {
                event.preventDefault();
                await downloadAllLogsZip();
            });

            // Download functions
            async function downloadSelectedLog() {
                const selectedValue = podSelector.value;
                if (!selectedValue || selectedValue === 'all') {
                    alert('Please select a specific pod to download logs.');
                    return;
                }

                try {
                    const selectedOption = podSelector.options[podSelector.selectedIndex];
                    const isArchivedLog = selectedOption.dataset.isArchived === "true";
                    const actualPodName = isArchivedLog ? selectedValue.substring("archived:".length) : selectedValue;
                    const source = isArchivedLog ? 'archived' : 'current';

                    const params = new URLSearchParams({
                        pod_name: actualPodName,
                        source: source
                    });

                    // Include API key if present
                    const currentUrlParams = new URLSearchParams(window.location.search);
                    const apiKey = currentUrlParams.get('api_key');
                    if (apiKey) {
                        params.set('api_key', apiKey);
                    }

                    // Create a temporary link and trigger download
                    const link = document.createElement('a');
                    link.href = `/api/download_log?${params.toString()}`;
                    link.download = '';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                } catch (error) {
                    console.error('Error downloading log:', error);
                    alert(`Error downloading log: ${error.message}`);
                }
            }

            async function downloadPodLogsZip() {
                const selectedValue = podSelector.value;
                if (!selectedValue || selectedValue === 'all') {
                    alert('Please select a specific pod to download logs.');
                    return;
                }

                try {
                    const selectedOption = podSelector.options[podSelector.selectedIndex];
                    const isArchivedLog = selectedOption.dataset.isArchived === "true";
                    const actualPodName = isArchivedLog ? selectedValue.substring("archived:".length) : selectedValue;

                    // Extract just the pod name (remove container part if present)
                    const podName = actualPodName.includes('/') ? actualPodName.split('/')[0] : actualPodName;

                    const params = new URLSearchParams({
                        pod_name: podName
                    });

                    // Include API key if present
                    const currentUrlParams = new URLSearchParams(window.location.search);
                    const apiKey = currentUrlParams.get('api_key');
                    if (apiKey) {
                        params.set('api_key', apiKey);
                    }

                    // Create a temporary link and trigger download
                    const link = document.createElement('a');
                    link.href = `/api/download_pod_logs?${params.toString()}`;
                    link.download = '';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                } catch (error) {
                    console.error('Error downloading pod logs:', error);
                    alert(`Error downloading pod logs: ${error.message}`);
                }
            }

            async function downloadAllLogsZip() {
                try {
                    // Include API key if present
                    const currentUrlParams = new URLSearchParams(window.location.search);
                    const apiKey = currentUrlParams.get('api_key');

                    let downloadUrl = '/api/download_all_logs';
                    if (apiKey) {
                        downloadUrl += `?api_key=${encodeURIComponent(apiKey)}`;
                    }

                    // Create a temporary link and trigger download
                    const link = document.createElement('a');
                    link.href = downloadUrl;
                    link.download = '';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                } catch (error) {
                    console.error('Error downloading all logs:', error);
                    alert(`Error downloading all logs: ${error.message}`);
                }
            }

            // Function to update download button states
            function updateDownloadButtonStates() {
                const selectedValue = podSelector.value;
                const hasSelection = selectedValue && selectedValue !== 'all';

                downloadCurrentLog.disabled = !hasSelection;
                downloadPodLogs.disabled = !hasSelection;
            }

            // Initial data fetch
            fetchUnifiedSources().then(() => {
                updateDownloadButtonStates();
                // Ensure selector defaults to "all" if no saved selection
                if (!podSelector.value || podSelector.value === '') {
                    podSelector.value = "all";
                    fetchAndDisplayData();
                }
            });
            fetchVersion();
        });
    </script>
</body>
</html>