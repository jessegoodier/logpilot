<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon" href="https://raw.githubusercontent.com/jessegoodier/logPilot/refs/heads/main/src/images/favicon.ico">
    <title>logPilot</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom scrollbar for webkit browsers */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #2d3748; /* dark:gray-700 */
        }
        ::-webkit-scrollbar-thumb {
            background: #4a5568; /* dark:gray-600 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #718096; /* dark:gray-500 */
        }
        .log-line mark { /* For search highlighting */
            background-color: #f6e05e; /* yellow-300 */
            color: #2d3748; /* gray-800 */
            padding: 0.1em;
            border-radius: 0.2em;
        }
        /* Basic transition for theme toggle */
        body, .bg-gray-100, .bg-gray-800, .text-gray-900, .text-gray-100 {
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .loader {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* ANSI Color Classes */
        .ansi-black { color: #2d3748; }
        .ansi-red { color: #e53e3e; }
        .ansi-green { color: #38a169; }
        .ansi-yellow { color: #d69e2e; }
        .ansi-blue { color: #3182ce; }
        .ansi-magenta { color: #d53f8c; }
        .ansi-cyan { color: #319795; }
        .ansi-white { color: #f7fafc; }
        
        .ansi-bright-black { color: #4a5568; }
        .ansi-bright-red { color: #fc8181; }
        .ansi-bright-green { color: #68d391; }
        .ansi-bright-yellow { color: #f6e05e; }
        .ansi-bright-blue { color: #63b3ed; }
        .ansi-bright-magenta { color: #f687b3; }
        .ansi-bright-cyan { color: #4fd1c7; }
        .ansi-bright-white { color: #ffffff; }
        
        /* Dark mode ANSI colors */
        .dark .ansi-black { color: #718096; }
        .dark .ansi-red { color: #fc8181; }
        .dark .ansi-green { color: #68d391; }
        .dark .ansi-yellow { color: #f6e05e; }
        .dark .ansi-blue { color: #63b3ed; }
        .dark .ansi-magenta { color: #f687b3; }
        .dark .ansi-cyan { color: #4fd1c7; }
        .dark .ansi-white { color: #f7fafc; }
        
        /* Error styling */
        .log-error {
            background-color: #fed7d7;
            color: #c53030;
            border-left: 4px solid #e53e3e;
            padding: 0.25rem 0.5rem;
            margin: 0.125rem 0;
        }
        .dark .log-error {
            background-color: #742a2a;
            color: #fc8181;
            border-left-color: #fc8181;
        }
        
        /* Retry button styling */
        .retry-button {
            display: inline-block;
            margin-left: 0.5rem;
            padding: 0.125rem 0.25rem;
            background-color: #4299e1;
            color: white;
            border: none;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            cursor: pointer;
            text-decoration: none;
        }
        .retry-button:hover {
            background-color: #3182ce;
        }
    </style>
    <script>
        // Tailwind dark mode configuration
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 font-sans antialiased">

    <div class="container mx-auto px-2 py-2 min-h-screen flex flex-col">
        <header class="bg-white dark:bg-gray-800 shadow-md rounded-lg p-2 mb-2 sticky top-0 z-10">
            <div class="relative">
                <button id="settingsButton" class="absolute top-0 right-0 p-1.5 rounded-md hover:bg-gray-200 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                    <img src="https://raw.githubusercontent.com/jessegoodier/logPilot/refs/heads/main/src/images/settings-gear.png" alt="Settings" class="w-5 h-5">
                </button>
                <div id="settingsMenu" class="hidden absolute right-0 mt-2 w-64 rounded-md shadow-lg bg-white dark:bg-gray-800 ring-1 ring-black ring-opacity-5 z-20">
                    <div class="py-1" role="menu" aria-orientation="vertical">
                        <div class="px-4 py-2 border-b border-gray-200 dark:border-gray-700">
                            <h3 class="text-sm font-medium text-gray-900 dark:text-gray-100">Settings</h3>
                        </div>

                        <div class="px-4 py-2">
                            <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Theme</label>
                            <div class="space-y-2">
                                <div class="flex items-center">
                                    <input type="radio" id="themeLight" name="theme" value="light" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 dark:border-gray-600">
                                    <label for="themeLight" class="ml-2 block text-sm text-gray-700 dark:text-gray-300">
                                        Light
                                    </label>
                                </div>
                                <div class="flex items-center">
                                    <input type="radio" id="themeDark" name="theme" value="dark" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 dark:border-gray-600">
                                    <label for="themeDark" class="ml-2 block text-sm text-gray-700 dark:text-gray-300">
                                        Dark
                                    </label>
                                </div>
                            </div>
                        </div>

                        <div class="px-4 py-2">
                            <label for="sortOrder" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Sort Order</label>
                            <select id="sortOrder" class="mt-1 block w-full py-2 px-3 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                                <option value="desc">Newest First</option>
                                <option value="asc">Oldest First</option>
                            </select>
                        </div>

                        <div class="px-4 py-2">
                            <label for="numLines" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Lines per Page</label>
                            <select id="numLines" class="mt-1 block w-full py-2 px-3 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                                <option value="100">Last 100</option>
                                <option value="1000">Last 1000</option>
                                <option value="0">All</option>
                            </select>
                        </div>

                        <div class="px-4 py-2">
                            <label for="timestampType" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Timestamp Format</label>
                            <select id="timestampType" class="mt-1 block w-full py-2 px-3 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                                <option value="since">Time Since</option>
                                <option value="utc">UTC</option>
                            </select>
                        </div>

                        <div class="px-4 py-2">
                            <div class="flex items-center">
                                <input type="checkbox" id="excludeSelf" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded" checked>
                                <label for="excludeSelf" class="ml-2 block text-sm text-gray-700 dark:text-gray-300">
                                    Exclude Self
                                </label>
                            </div>
                        </div>

                        <div class="px-4 py-2 border-t border-gray-200 dark:border-gray-700">
                            <button id="storageStatsButton" class="w-full py-2 px-3 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 dark:bg-indigo-500 dark:hover:bg-indigo-600">
                                Storage Stats
                            </button>
                        </div>

                        <div class="px-4 py-2 border-t border-gray-200 dark:border-gray-700">
                            <div class="text-xs text-gray-500 dark:text-gray-400 text-center">
                                Version: <span id="appVersion">Loading...</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- View Mode Toggle -->
            <div class="mb-4">
                <div class="flex bg-gray-200 dark:bg-gray-700 rounded-lg p-1 w-fit">
                    <button id="logsToggle" class="px-4 py-2 text-sm font-medium rounded-md transition-colors bg-white dark:bg-gray-600 text-gray-900 dark:text-gray-100 shadow-sm">
                        üìã Logs
                    </button>
                    <button id="eventsToggle" class="px-4 py-2 text-sm font-medium rounded-md transition-colors text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100">
                        üìÖ Events
                    </button>
                </div>
            </div>

            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 items-end mt-2">
                <div>
                    <label for="podSelector" class="block text-sm font-medium text-gray-700 dark:text-gray-300"><span id="selectorLabel">Pod</span> <a href="#" id="refreshPods" class="text-indigo-600 dark:text-indigo-400 hover:text-indigo-800 dark:hover:text-indigo-300 text-xs">(Refresh)</a></label>
                    <select id="podSelector" class="mt-1 block w-full py-2 px-3 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                        <option value="all">All Pods</option>
                    </select>
                </div>

                <div>
                    <label for="searchBox" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Search <a href="#" id="clearSearch" class="text-indigo-600 dark:text-indigo-400 hover:text-indigo-800 dark:hover:text-indigo-300 text-xs">(Clear)</a></label>
                    <div class="mt-1 relative">
                        <input type="text" id="searchBox" placeholder="Enter to search..." title="Search searches all available logs, not just the current page. Results are then limited by Lines per Page setting." class="block w-full py-2 px-3 pr-24 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                        <div class="absolute inset-y-0 right-0 pr-3 flex items-center space-x-2">
                            <button id="highlightToggle" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 focus:outline-none" title="Toggle search term highlighting">
                                <span class="text-sm font-mono">H</span>
                            </button>
                            <button id="caseSensitiveToggle" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 focus:outline-none" title="Toggle case sensitivity">
                                <span class="text-sm font-mono">Aa</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            <div id="namespaceDisplay" class="mt-3 text-xs text-gray-500 dark:text-gray-400">Namespace: <span id="namespaceValue">Loading...</span></div>
            <div id="errorDisplay" class="mt-2 text-sm text-red-600 dark:text-red-400"></div>
            <div id="loadingIndicator" class="hidden mt-2">
                <div class="loader"></div>
                <p class="text-center text-sm text-gray-500 dark:text-gray-400">Loading logs...</p>
            </div>
        </header>

        <main class="flex-grow bg-white dark:bg-gray-800 shadow-md rounded-lg p-2 overflow-hidden">
            <pre id="logOutput" class="whitespace-pre-wrap break-all overflow-auto h-full text-sm leading-relaxed"></pre>
        </main>
    </div>

    <!-- Storage Stats Modal -->
    <div id="storageStatsModal" class="hidden fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full mx-4">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-medium text-gray-900 dark:text-gray-100">Storage Statistics</h3>
                <button id="closeStorageStats" class="text-gray-400 hover:text-gray-500 focus:outline-none">
                    <span class="sr-only">Close</span>
                    <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            <div id="storageStatsContent" class="space-y-4">
                <div class="animate-pulse">
                    <div class="h-4 bg-gray-200 dark:bg-gray-700 rounded w-3/4 mb-2"></div>
                    <div class="h-4 bg-gray-200 dark:bg-gray-700 rounded w-1/2 mb-2"></div>
                    <div class="h-4 bg-gray-200 dark:bg-gray-700 rounded w-2/3"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const podSelector = document.getElementById('podSelector');
            const sortOrder = document.getElementById('sortOrder');
            const numLines = document.getElementById('numLines');
            const timestampType = document.getElementById('timestampType');
            const searchBox = document.getElementById('searchBox');
            const themeLight = document.getElementById('themeLight');
            const themeDark = document.getElementById('themeDark');
            const logOutput = document.getElementById('logOutput');
            const namespaceValue = document.getElementById('namespaceValue');
            const errorDisplay = document.getElementById('errorDisplay');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const clearSearch = document.getElementById('clearSearch');
            const refreshPods = document.getElementById('refreshPods');
            const settingsButton = document.getElementById('settingsButton');
            const settingsMenu = document.getElementById('settingsMenu');
            const excludeSelf = document.getElementById('excludeSelf');
            const storageStatsButton = document.getElementById('storageStatsButton');
            const storageStatsModal = document.getElementById('storageStatsModal');
            const closeStorageStats = document.getElementById('closeStorageStats');
            const storageStatsContent = document.getElementById('storageStatsContent');
            const appVersion = document.getElementById('appVersion');
            const caseSensitiveToggle = document.getElementById('caseSensitiveToggle');
            const highlightToggle = document.getElementById('highlightToggle');
            const logsToggle = document.getElementById('logsToggle');
            const eventsToggle = document.getElementById('eventsToggle');
            const selectorLabel = document.getElementById('selectorLabel');

            let currentLogs = [];
            let currentEvents = [];
            let currentPodName = null;
            let caseSensitive = localStorage.getItem('caseSensitive') === 'true';
            let highlightEnabled = localStorage.getItem('highlightEnabled') !== 'false'; // Default to true if not set
            let viewMode = localStorage.getItem('viewMode') || 'logs'; // 'logs' or 'events'

            // Shared color mapping for consistent colors across logs and events
            let globalPodColorMap = new Map();
            let globalColorIndex = 0;
            
            // Define pod colors - using a mix of colors that work well in both light and dark modes
            const podColors = [
                ['text-blue-600', 'dark:text-blue-400'],
                ['text-purple-600', 'dark:text-purple-400'],
                ['text-cyan-600', 'dark:text-cyan-400'],
                ['text-emerald-600', 'dark:text-emerald-400'],
                ['text-amber-600', 'dark:text-amber-400'],
                ['text-rose-600', 'dark:text-rose-400'],
                ['text-violet-600', 'dark:text-violet-400'],
                ['text-teal-600', 'dark:text-teal-400'],
                ['text-orange-600', 'dark:text-orange-400'],
                ['text-pink-600', 'dark:text-pink-400']
            ];

            function getOrCreateColorMapping() {
                return {
                    podColorMap: globalPodColorMap,
                    colorIndex: globalColorIndex,
                    updateColorIndex: (newIndex) => { globalColorIndex = newIndex; }
                };
            }

            // --- Version Information ---
            async function fetchVersion() {
                try {
                    const versionData = await fetchFromServer('/api/version');
                    appVersion.textContent = versionData.version || 'Unknown';
                } catch (error) {
                    console.warn('Could not fetch version information:', error.message);
                    appVersion.textContent = 'Unknown';
                }
            }

            // --- Storage Stats Modal ---
            async function updateStorageStats() {
                try {
                    const [stats, capability, archivedPods] = await Promise.all([
                        fetchFromServer('/api/logDirStats'),
                        fetchFromServer('/api/purgeCapability'),
                        fetchFromServer('/api/archived_pods')
                    ]);
                    let content = '';
                    
                    if (stats.enabled) {
                        const hasPreviousPods = archivedPods.archived_pods && archivedPods.archived_pods.length > 0;
                        const purgeButtonHtml = capability.purge_allowed && hasPreviousPods
                            ? `<div class="pt-4 border-t border-gray-200 dark:border-gray-700">
                                    <button id="purgePreviousLogsButton" class="w-full py-2 px-3 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 dark:bg-red-500 dark:hover:bg-red-600">
                                        Purge Previous Pod Logs
                                    </button>
                                </div>`
                            : '';
                        
                        content = `
                            <div class="space-y-4">
                                <div>
                                    <h4 class="text-sm font-medium text-gray-700 dark:text-gray-300">Total Size</h4>
                                    <p class="text-lg font-semibold text-gray-900 dark:text-gray-100">${stats.total_size_mibytes.toFixed(2)} MiB</p>
                                </div>
                                <div>
                                    <h4 class="text-sm font-medium text-gray-700 dark:text-gray-300">Number of Files</h4>
                                    <p class="text-lg font-semibold text-gray-900 dark:text-gray-100">${stats.file_count}</p>
                                </div>
                                <div>
                                    <h4 class="text-sm font-medium text-gray-700 dark:text-gray-300">Oldest File</h4>
                                    <p class="text-lg font-semibold text-gray-900 dark:text-gray-100">${stats.oldest_file_date || 'N/A'}</p>
                                </div>
                                <div>
                                    <h4 class="text-sm font-medium text-gray-700 dark:text-gray-300">Log Directory</h4>
                                    <p class="text-lg font-semibold text-gray-900 dark:text-gray-100">${stats.log_directory}</p>
                                </div>
                                ${purgeButtonHtml}
                            </div>
                        `;
                    } else {
                        content = `
                            <div class="text-center py-4">
                                <p class="text-gray-700 dark:text-gray-300">${stats.message}</p>
                            </div>
                        `;
                    }
                    storageStatsContent.innerHTML = content;
                } catch (error) {
                    storageStatsContent.innerHTML = `
                        <div class="text-center py-4">
                            <p class="text-red-600 dark:text-red-400">Error loading storage stats: ${error.message}</p>
                        </div>
                    `;
                }
            }

            // Add event delegation for the purge button
            storageStatsContent.addEventListener('click', async (event) => {
                if (event.target.id === 'purgePreviousLogsButton') {
                    if (!confirm('Are you sure you want to delete all previous pod log files? This action cannot be undone.')) {
                        return;
                    }
                    
                    try {
                        const response = await fetchFromServer('/api/purgePreviousLogs', {
                            method: 'POST'
                        });
                        
                        if (response.success) {
                            alert(`Successfully purged ${response.deleted_count} previous pod log files.`);
                            // Close the modal
                            storageStatsModal.classList.add('hidden');
                            // Set pod selector to "all"
                            podSelector.value = "all";
                            // Refresh the pod list and logs
                            await fetchPods();
                        } else {
                            alert(`Error: ${response.message}`);
                        }
                    } catch (error) {
                        alert(`Error purging previous pod logs: ${error.message}`);
                    }
                }
            });

            storageStatsButton.addEventListener('click', () => {
                settingsMenu.classList.add('hidden');
                storageStatsModal.classList.remove('hidden');
                updateStorageStats();
            });

            closeStorageStats.addEventListener('click', () => {
                storageStatsModal.classList.add('hidden');
            });

            // Close modal when clicking outside
            storageStatsModal.addEventListener('click', (event) => {
                if (event.target === storageStatsModal) {
                    storageStatsModal.classList.add('hidden');
                }
            });

            // Close modal with Escape key
            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape' && !storageStatsModal.classList.contains('hidden')) {
                    storageStatsModal.classList.add('hidden');
                }
            });

            // --- Theme Toggle ---
            const applyTheme = () => {
                if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                    document.documentElement.classList.add('dark');
                    themeDark.checked = true;
                } else {
                    document.documentElement.classList.remove('dark');
                    themeLight.checked = true;
                }
            };

            themeLight.addEventListener('change', () => {
                if (themeLight.checked) {
                    localStorage.theme = 'light';
                    applyTheme();
                }
            });

            themeDark.addEventListener('change', () => {
                if (themeDark.checked) {
                    localStorage.theme = 'dark';
                    applyTheme();
                }
            });

            applyTheme();

            // --- Case Sensitivity Toggle ---
            const updateCaseSensitiveDisplay = () => {
                if (caseSensitive) {
                    caseSensitiveToggle.classList.remove('text-gray-400');
                    caseSensitiveToggle.classList.add('text-indigo-600', 'dark:text-indigo-400');
                    caseSensitiveToggle.title = 'Case sensitive search (click to toggle)';
                } else {
                    caseSensitiveToggle.classList.remove('text-indigo-600', 'dark:text-indigo-400');
                    caseSensitiveToggle.classList.add('text-gray-400');
                    caseSensitiveToggle.title = 'Case insensitive search (click to toggle)';
                }
            };

            // --- Highlight Toggle ---
            const updateHighlightDisplay = () => {
                if (highlightEnabled) {
                    highlightToggle.classList.remove('text-gray-400');
                    highlightToggle.classList.add('text-indigo-600', 'dark:text-indigo-400');
                    highlightToggle.title = 'Search term highlighting enabled (click to toggle)';
                } else {
                    highlightToggle.classList.remove('text-indigo-600', 'dark:text-indigo-400');
                    highlightToggle.classList.add('text-gray-400');
                    highlightToggle.title = 'Search term highlighting disabled (click to toggle)';
                }
            };

            caseSensitiveToggle.addEventListener('click', (event) => {
                event.preventDefault();
                caseSensitive = !caseSensitive;
                localStorage.setItem('caseSensitive', caseSensitive.toString());
                updateCaseSensitiveDisplay();
                if (searchBox.value.trim()) {
                    fetchAndDisplayData();
                }
            });

            highlightToggle.addEventListener('click', (event) => {
                event.preventDefault();
                highlightEnabled = !highlightEnabled;
                localStorage.setItem('highlightEnabled', highlightEnabled.toString());
                updateHighlightDisplay();
                // Just re-render since we don't need to fetch again
                if (viewMode === 'logs') {
                    renderLogs();
                } else {
                    renderEvents();
                }
            });

            // Initialize display states
            updateCaseSensitiveDisplay();
            updateHighlightDisplay();

            // --- View Mode Toggle ---
            const updateViewModeDisplay = () => {
                if (viewMode === 'logs') {
                    logsToggle.classList.add('bg-white', 'dark:bg-gray-600', 'text-gray-900', 'dark:text-gray-100', 'shadow-sm');
                    logsToggle.classList.remove('text-gray-600', 'dark:text-gray-400');
                    eventsToggle.classList.remove('bg-white', 'dark:bg-gray-600', 'text-gray-900', 'dark:text-gray-100', 'shadow-sm');
                    eventsToggle.classList.add('text-gray-600', 'dark:text-gray-400');
                    selectorLabel.textContent = 'Pod';
                } else {
                    eventsToggle.classList.add('bg-white', 'dark:bg-gray-600', 'text-gray-900', 'dark:text-gray-100', 'shadow-sm');
                    eventsToggle.classList.remove('text-gray-600', 'dark:text-gray-400');
                    logsToggle.classList.remove('bg-white', 'dark:bg-gray-600', 'text-gray-900', 'dark:text-gray-100', 'shadow-sm');
                    logsToggle.classList.add('text-gray-600', 'dark:text-gray-400');
                    selectorLabel.textContent = 'Object';
                }
            };

            logsToggle.addEventListener('click', () => {
                if (viewMode !== 'logs') {
                    const previousSelection = podSelector.value; // Store current selection
                    viewMode = 'logs';
                    localStorage.setItem('viewMode', viewMode);
                    updateViewModeDisplay();
                    fetchPodsAndRestoreSelection(previousSelection); // Refresh and try to restore selection
                }
            });

            eventsToggle.addEventListener('click', () => {
                if (viewMode !== 'events') {
                    const previousSelection = podSelector.value; // Store current selection
                    viewMode = 'events';
                    localStorage.setItem('viewMode', viewMode);
                    updateViewModeDisplay();
                    fetchEventSourcesAndRestoreSelection(previousSelection); // Refresh and try to restore selection
                }
            });

            // Initialize view mode
            updateViewModeDisplay();

            // --- API Calls ---
            async function fetchFromServer(endpoint, options = {}) {
                errorDisplay.textContent = '';
                try {
                    const absoluteUrl = new URL(endpoint, window.location.href).href;
                    const response = await fetch(absoluteUrl, options);

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ 
                            message: `HTTP error! status: ${response.status} on ${absoluteUrl}`,
                            error_type: 'http_error',
                            retry_suggested: response.status >= 500 || response.status === 429
                        }));
                        
                        // Enhanced error with metadata
                        const enhancedError = new Error(errorData.message || `HTTP error! status: ${response.status} on ${absoluteUrl}`);
                        enhancedError.errorType = errorData.error_type || 'http_error';
                        enhancedError.retrySuggested = errorData.retry_suggested || false;
                        enhancedError.statusCode = response.status;
                        enhancedError.endpoint = endpoint;
                        throw enhancedError;
                    }
                    return await response.json();
                } catch (error) {
                    console.error(`Error fetching ${endpoint} (resolved to ${new URL(endpoint, window.location.href).href}):`, error);
                    
                    // Enhanced error display with retry suggestion
                    let errorMessage = `Error: ${error.message}`;
                    if (error.retrySuggested) {
                        errorMessage += ' (Retry recommended)';
                    }
                    errorDisplay.textContent = errorMessage;
                    
                    throw error;
                }
            }

            function formatTimestamp(timestamp) {
                if (!timestamp) return '-';
                try {
                    const date = new Date(timestamp);
                    const now = new Date();
                    const diffMs = now - date;
                    const diffMinutes = Math.floor(diffMs / 60000);
                    const diffHours = Math.floor(diffMinutes / 60);
                    const diffDays = Math.floor(diffHours / 24);
                    
                    if (diffMinutes < 1) {
                        return 'Just now';
                    } else if (diffMinutes < 60) {
                        return `${diffMinutes}m ago`;
                    } else if (diffHours < 24) {
                        return `${diffHours}h ago`;
                    } else if (diffDays < 7) {
                        return `${diffDays}d ago`;
                    } else {
                        return date.toLocaleDateString();
                    }
                } catch (e) {
                    return timestamp.substring(0, 16);
                }
            }

            function getHealthStatusEmoji(status) {
                const statusEmojis = {
                    'healthy': '‚úÖ',
                    'partial': '‚ö†Ô∏è',
                    'unhealthy': '‚ùå',
                    'pending': '‚è≥',
                    'waiting': '‚è∏Ô∏è',
                    'terminated': '‚èπÔ∏è',
                    'failed': 'üí•',
                    'succeeded': '‚úÖ',
                    'unknown': '‚ùì',
                    'error': 'üö®'
                };
                return statusEmojis[status] || '‚ùì';
            }

            function formatOptionText(podInfo, maxPodLength, maxContainerLength) {
                const healthEmoji = getHealthStatusEmoji(podInfo.health_status);
                const timeText = formatTimestamp(podInfo.last_log_time);
                
                // Split pod and container for separate columns
                let podName, containerName;
                if (podInfo.id.includes('/')) {
                    const parts = podInfo.id.split('/');
                    podName = parts[0];
                    containerName = parts[1];
                } else {
                    podName = podInfo.id;
                    containerName = podInfo.container_name;
                }
                
                // Add type indicators
                if (podInfo.type === 'init_container') {
                    containerName = `${containerName} [INIT]`;
                } else if (podInfo.type === 'pod' && containerName === podName) {
                    containerName = '-'; // Single container pod
                }
                
                // Pad both columns for alignment (use fixed width for emojis)
                const paddedPod = podName.padEnd(maxPodLength);
                const paddedContainer = containerName.padEnd(maxContainerLength);
                
                // Format: Pod | Container | Status | Last Log Time  
                return `${paddedPod} | ${paddedContainer} | ${healthEmoji} | ${timeText}`;
            }

            function formatUnifiedOptionText(source, maxPodLength, maxContainerLength, viewMode) {
                let podName, containerName;
                
                if (source.sourceType === 'event_source') {
                    // For event sources, show Kind/Name format
                    podName = source.pod_name;
                    containerName = source.container_name; // This contains the Kind
                } else {
                    // For pods, use existing logic
                    if (source.id.includes('/')) {
                        const parts = source.id.split('/');
                        podName = parts[0];
                        containerName = parts[1];
                    } else {
                        podName = source.pod_name || source.id;
                        containerName = source.container_name;
                    }
                    
                    // Add type indicators
                    if (source.type === 'init_container') {
                        containerName = `${containerName} [INIT]`;
                    } else if (source.type === 'pod' && containerName === podName) {
                        containerName = '-'; // Single container pod
                    }
                }
                
                // Determine status emoji/indicator
                let statusEmoji;
                if (source.sourceType === 'event_source') {
                    statusEmoji = source.health_status === 'warning' ? '‚ö†Ô∏è' : 'üìÖ';
                } else if (source.sourceType === 'archived') {
                    statusEmoji = 'üìÅ';
                } else {
                    statusEmoji = getHealthStatusEmoji(source.health_status);
                    // Add indicator if this source has both logs and events
                    if (source.hasLogs && source.hasEvents) {
                        statusEmoji += 'üìÖ'; // Add event indicator
                    }
                }
                
                // Format time
                const timeText = formatTimestamp(source.last_log_time);
                
                // Pad for alignment
                const paddedPod = podName.padEnd(maxPodLength);
                const paddedContainer = containerName.padEnd(maxContainerLength);
                
                return `${paddedPod} | ${paddedContainer} | ${statusEmoji} | ${timeText}`;
            }

            function calculateMaxLengths(livePodsData, archivedPodsData, currentPodName) {
                let maxPodLength = 8; // Minimum for "All Pods"
                let maxContainerLength = 9; // Minimum for "Container"
                
                // Check live pods
                if (livePodsData.pods && livePodsData.pods.length > 0) {
                    livePodsData.pods.forEach(podInfo => {
                        let podName, containerName;
                        if (podInfo.id.includes('/')) {
                            const parts = podInfo.id.split('/');
                            podName = parts[0];
                            containerName = parts[1];
                        } else {
                            podName = podInfo.id;
                            containerName = podInfo.container_name;
                        }
                        
                        // Add type indicators for container length calculation
                        if (podInfo.type === 'init_container') {
                            containerName = `${containerName} [INIT]`;
                        } else if (podInfo.type === 'pod' && containerName === podName) {
                            containerName = '-';
                        }
                        
                        maxPodLength = Math.max(maxPodLength, podName.length);
                        maxContainerLength = Math.max(maxContainerLength, containerName.length);
                    });
                }
                
                // Check current pod if not in live pods
                if (currentPodName) {
                    maxPodLength = Math.max(maxPodLength, currentPodName.length);
                    maxContainerLength = Math.max(maxContainerLength, '-'.length);
                }
                
                // Check archived pods
                if (archivedPodsData.archived_pods && archivedPodsData.archived_pods.length > 0) {
                    archivedPodsData.archived_pods.forEach(podName => {
                        maxPodLength = Math.max(maxPodLength, podName.length);
                        maxContainerLength = Math.max(maxContainerLength, '[ARCHIVED]'.length);
                    });
                }
                
                return { maxPodLength, maxContainerLength };
            }

            function createUnifiedSourceList(livePodsData, eventSourcesData, archivedPodsData, currentPodName) {
                const unifiedSources = [];
                const seenKeys = new Set();

                // Add live pods first
                if (livePodsData.pods && livePodsData.pods.length > 0) {
                    livePodsData.pods.forEach(podInfo => {
                        const key = podInfo.id;
                        if (!seenKeys.has(key)) {
                            unifiedSources.push({
                                ...podInfo,
                                sourceType: 'pod',
                                hasLogs: true,
                                hasEvents: false // Will be updated if found in events
                            });
                            seenKeys.add(key);
                        }
                    });
                }

                // Add current pod if not in live pods and excludeSelf is unchecked
                if (!excludeSelf.checked && currentPodName && !seenKeys.has(currentPodName)) {
                    unifiedSources.push({
                        id: currentPodName,
                        pod_name: currentPodName,
                        container_name: currentPodName,
                        type: 'pod',
                        health_status: 'unknown',
                        health_reason: 'Current pod (limited info available)',
                        last_log_time: null,
                        created_time: null,
                        sourceType: 'pod',
                        hasLogs: true,
                        hasEvents: false
                    });
                    seenKeys.add(currentPodName);
                }

                // Add event sources and mark existing pods as having events
                if (eventSourcesData.sources && eventSourcesData.sources.length > 0) {
                    eventSourcesData.sources.forEach(source => {
                        const podKey = source.object_name; // Try to match by pod name
                        const fullKey = source.id; // Full "Kind/Name" format

                        // Check if this is a pod we already have
                        let existingPod = unifiedSources.find(s => 
                            s.pod_name === source.object_name || 
                            s.id === source.object_name ||
                            s.id.includes(source.object_name)
                        );

                        if (existingPod) {
                            // Mark existing pod as having events
                            existingPod.hasEvents = true;
                            existingPod.eventInfo = source;
                        } else if (!seenKeys.has(fullKey)) {
                            // Add as new event-only source
                            unifiedSources.push({
                                id: fullKey,
                                pod_name: source.object_name,
                                container_name: `${source.object_kind}`,
                                type: 'event_source',
                                health_status: source.latest_event_type === 'Warning' ? 'warning' : 'normal',
                                health_reason: `${source.event_count} events`,
                                last_log_time: source.latest_timestamp,
                                created_time: null,
                                sourceType: 'event_source',
                                hasLogs: false,
                                hasEvents: true,
                                eventInfo: source
                            });
                            seenKeys.add(fullKey);
                        }
                    });
                }

                // Add archived pods
                if (archivedPodsData.archived_pods && archivedPodsData.archived_pods.length > 0) {
                    const livePodNames = new Set(livePodsData.pods?.map(p => p.id) || []);
                    const filteredArchivedPods = archivedPodsData.archived_pods.filter(
                        podName => !livePodNames.has(podName) && !seenKeys.has(`archived:${podName}`)
                    );

                    filteredArchivedPods.forEach(podName => {
                        const archivedKey = `archived:${podName}`;
                        unifiedSources.push({
                            id: archivedKey,
                            pod_name: podName,
                            container_name: '[ARCHIVED]',
                            type: 'archived',
                            health_status: 'archived',
                            health_reason: 'Archived pod logs',
                            last_log_time: null,
                            created_time: null,
                            sourceType: 'archived',
                            hasLogs: true,
                            hasEvents: false
                        });
                        seenKeys.add(archivedKey);
                    });
                }

                return unifiedSources;
            }

            function calculateMaxLengthsUnified(unifiedSources) {
                let maxPodLength = 8; // Minimum for headers
                let maxContainerLength = 9;
                
                unifiedSources.forEach(source => {
                    let podName, containerName;
                    if (source.id.includes('/')) {
                        const parts = source.id.split('/');
                        podName = parts[0];
                        containerName = parts[1];
                    } else {
                        podName = source.pod_name || source.id;
                        containerName = source.container_name;
                    }
                    
                    if (source.type === 'init_container') {
                        containerName = `${containerName} [INIT]`;
                    } else if (source.type === 'pod' && containerName === podName) {
                        containerName = '-';
                    }
                    
                    maxPodLength = Math.max(maxPodLength, podName.length);
                    maxContainerLength = Math.max(maxContainerLength, containerName.length);
                });
                
                return { maxPodLength, maxContainerLength };
            }

            async function fetchEventSources() {
                try {
                    // Store current selection before refresh
                    const currentSelection = podSelector.value;

                    const eventSourcesData = await fetchFromServer('/api/event_sources');
                    namespaceValue.textContent = eventSourcesData.namespace || 'N/A';

                    // Calculate maximum lengths for alignment
                    let maxObjectLength = 15; // Minimum for "All Objects"
                    let maxKindLength = 10; // Minimum for "Kind"
                    
                    if (eventSourcesData.sources && eventSourcesData.sources.length > 0) {
                        eventSourcesData.sources.forEach(source => {
                            maxObjectLength = Math.max(maxObjectLength, source.object_name.length);
                            maxKindLength = Math.max(maxKindLength, source.object_kind.length);
                        });
                    }
                    
                    // Create aligned header
                    const headerObject = "Object".padEnd(maxObjectLength);
                    const headerKind = "Kind".padEnd(maxKindLength);
                    
                    // Reset selector with aligned header and "All Objects" option
                    const allObjectsName = "All Objects".padEnd(maxObjectLength);
                    const allObjectsKind = "-".padEnd(maxKindLength);
                    podSelector.innerHTML = `
                        <option value="" disabled style="font-weight: bold; color: #6b7280; background-color: #f9fafb;">‚îÄ‚îÄ ${headerObject} | ${headerKind} | Events | Last Event ‚îÄ‚îÄ</option>
                        <option value="all">${allObjectsName} | ${allObjectsKind} | üìÖ | -</option>
                    `;

                    if (eventSourcesData.sources && eventSourcesData.sources.length > 0) {
                        const sourcesGroup = document.createElement('optgroup');
                        sourcesGroup.label = "Event Sources";
                        
                        eventSourcesData.sources.forEach(source => {
                            const paddedName = source.object_name.padEnd(maxObjectLength);
                            const paddedKind = source.object_kind.padEnd(maxKindLength);
                            const eventEmoji = source.latest_event_type === 'Warning' ? '‚ö†Ô∏è' : 'üìÖ';
                            const timeText = formatTimestamp(source.latest_timestamp);
                            
                            const option = document.createElement('option');
                            option.value = source.id;
                            option.textContent = `${paddedName} | ${paddedKind} | ${eventEmoji} | ${timeText}`;
                            option.title = `${source.object_kind}/${source.object_name} - ${source.event_count} events`;
                            sourcesGroup.appendChild(option);
                        });
                        
                        podSelector.appendChild(sourcesGroup);
                    } else {
                        const noSourcesText = "No event sources found".padEnd(maxObjectLength);
                        const noSourcesKind = "-".padEnd(maxKindLength);
                        podSelector.innerHTML = `
                            <option value="" disabled style="font-weight: bold; color: #6b7280; background-color: #f9fafb;">‚îÄ‚îÄ ${headerObject} | ${headerKind} | Events | Last Event ‚îÄ‚îÄ</option>
                            <option value="all">${noSourcesText} | ${noSourcesKind} | ‚ùå | -</option>
                        `;
                    }

                    // Try to restore previous selection
                    if (currentSelection) {
                        const optionExists = Array.from(podSelector.options).some(option => option.value === currentSelection);
                        if (optionExists) {
                            podSelector.value = currentSelection;
                        } else {
                            podSelector.value = "all";
                        }
                    } else {
                        podSelector.value = "all";
                    }

                    // Refresh data for the current selection
                    fetchAndDisplayData();
                } catch (error) {
                    namespaceValue.textContent = 'Error loading';
                    errorDisplay.textContent = `Error fetching event sources: ${error.message}`;
                    
                    const defaultMaxObjectLength = 15;
                    const defaultMaxKindLength = 10;
                    const headerObject = "Object".padEnd(defaultMaxObjectLength);
                    const headerKind = "Kind".padEnd(defaultMaxKindLength);
                    const errorText = "Error loading".padEnd(defaultMaxObjectLength);
                    const errorKind = "-".padEnd(defaultMaxKindLength);
                    podSelector.innerHTML = `
                        <option value="" disabled style="font-weight: bold; color: #6b7280; background-color: #f9fafb;">‚îÄ‚îÄ ${headerObject} | ${headerKind} | Events | Last Event ‚îÄ‚îÄ</option>
                        <option value="all">${errorText} | ${errorKind} | ‚ùå | -</option>
                    `;
                }
            }

            // Helper function to find the best matching selection when switching views
            function findBestMatch(previousSelection, availableOptions) {
                if (!previousSelection || previousSelection === 'all') {
                    return 'all';
                }

                // Try exact match first
                for (const option of availableOptions) {
                    if (option.value === previousSelection) {
                        return previousSelection;
                    }
                }

                // For logs->events: try to match pod name to object name
                // For events->logs: try to match object name to pod name
                let extractedName = '';
                if (previousSelection.includes('/')) {
                    // Extract the object/pod name part
                    const parts = previousSelection.split('/');
                    extractedName = parts[parts.length - 1]; // Get the last part (name)
                }

                // Try to find a partial match
                for (const option of availableOptions) {
                    if (option.value === 'all' || !option.value) continue;
                    
                    // Check if the extracted name appears in this option
                    if (extractedName && option.value.includes(extractedName)) {
                        return option.value;
                    }
                    
                    // Check if any part of the previous selection matches
                    if (option.value.includes(previousSelection) || previousSelection.includes(option.value)) {
                        return option.value;
                    }
                }

                // Fallback to 'all' if no match found
                return 'all';
            }

            async function fetchPodsAndRestoreSelection(previousSelection) {
                try {
                    await fetchUnifiedSources();
                    
                    // Try to restore or find best match for the selection
                    const bestMatch = findBestMatch(previousSelection, Array.from(podSelector.options));
                    podSelector.value = bestMatch;
                    
                    // Trigger data fetch for the restored selection
                    fetchAndDisplayData();
                } catch (error) {
                    console.error('Error in fetchPodsAndRestoreSelection:', error);
                }
            }

            async function fetchEventSourcesAndRestoreSelection(previousSelection) {
                try {
                    await fetchUnifiedSources();
                    
                    // Try to restore or find best match for the selection
                    const bestMatch = findBestMatch(previousSelection, Array.from(podSelector.options));
                    podSelector.value = bestMatch;
                    
                    // Trigger data fetch for the restored selection
                    fetchAndDisplayData();
                } catch (error) {
                    console.error('Error in fetchEventSourcesAndRestoreSelection:', error);
                }
            }

            // Keep the old functions for backward compatibility but make them call the unified function
            async function fetchPods() {
                return fetchUnifiedSources();
            }

            async function fetchEventSources() {
                return fetchUnifiedSources();
            }

            async function fetchUnifiedSources() {
                try {
                    // Store current selection before refresh
                    const currentSelection = podSelector.value;

                    // Fetch both pods and event sources to create a unified list
                    const params = new URLSearchParams();
                    if (excludeSelf.checked) {
                        params.append('exclude_self', 'true');
                    }
                    
                    const [livePodsData, eventSourcesData] = await Promise.all([
                        fetchFromServer(`/api/pods?${params.toString()}`),
                        fetchFromServer('/api/event_sources')
                    ]);
                    
                    namespaceValue.textContent = livePodsData.namespace || eventSourcesData.namespace || 'N/A';
                    currentPodName = livePodsData.current_pod || null;

                    // Fetch archived pods
                    let archivedPodsData = { archived_pods: [] };
                    try {
                        archivedPodsData = await fetchFromServer('/api/archived_pods');
                    } catch (error) {
                        console.warn("Could not fetch archived pods, possibly disabled:", error.message);
                    }

                    // Create unified source list combining pods, event sources, and archived pods
                    const unifiedSources = createUnifiedSourceList(livePodsData, eventSourcesData, archivedPodsData, currentPodName);

                    // Calculate maximum lengths for alignment
                    const { maxPodLength, maxContainerLength } = calculateMaxLengthsUnified(unifiedSources);
                    
                    // Create aligned header - adjust label based on view mode
                    const headerPod = (viewMode === 'events' ? "Object" : "Pod").padEnd(maxPodLength);
                    const headerContainer = (viewMode === 'events' ? "Kind/Container" : "Container").padEnd(maxContainerLength);
                    
                    // Reset selector with aligned header and "All" option
                    const allLabel = viewMode === 'events' ? "All Objects" : "All Pods";
                    const allPadded = allLabel.padEnd(maxPodLength);
                    const allContainerPadded = "-".padEnd(maxContainerLength);
                    const statusLabel = viewMode === 'events' ? "Events" : "Status";
                    const timeLabel = viewMode === 'events' ? "Last Event" : "Last Log";
                    
                    podSelector.innerHTML = `
                        <option value="" disabled style="font-weight: bold; color: #6b7280; background-color: #f9fafb;">‚îÄ‚îÄ ${headerPod} | ${headerContainer} | ${statusLabel} | ${timeLabel} ‚îÄ‚îÄ</option>
                        <option value="all">${allPadded} | ${allContainerPadded} | üåê | -</option>
                    `;

                    const createOption = (value, text, isArchived = false, sourceInfo = null) => {
                        const option = document.createElement('option');
                        option.value = isArchived ? `archived:${value}` : value;
                        option.textContent = text;
                        if (isArchived) {
                            option.dataset.isArchived = "true";
                        }
                        if (sourceInfo) {
                            option.dataset.hasLogs = sourceInfo.hasLogs;
                            option.dataset.hasEvents = sourceInfo.hasEvents;
                            option.dataset.sourceType = sourceInfo.sourceType;
                        }
                        return option;
                    };

                    // Render unified sources
                    if (unifiedSources.length > 0) {
                        // Group sources by type
                        const liveSourcesWithLogs = unifiedSources.filter(s => s.hasLogs && s.sourceType !== 'archived');
                        const eventOnlySources = unifiedSources.filter(s => s.hasEvents && !s.hasLogs && s.sourceType !== 'archived');
                        const archivedSources = unifiedSources.filter(s => s.sourceType === 'archived');
                        
                        // Add live sources with logs
                        if (liveSourcesWithLogs.length > 0) {
                            const liveGroup = document.createElement('optgroup');
                            liveGroup.label = viewMode === 'events' ? "Objects with Events" : "Live Pods";
                            
                            liveSourcesWithLogs.sort((a, b) => a.id.localeCompare(b.id)).forEach(source => {
                                const optionText = formatUnifiedOptionText(source, maxPodLength, maxContainerLength, viewMode);
                                const option = createOption(source.id, optionText, false, source);
                                
                                // Create tooltip based on what data is available
                                let tooltipParts = [];
                                if (source.hasLogs) tooltipParts.push('Has logs');
                                if (source.hasEvents) tooltipParts.push(`${source.eventInfo?.event_count || 'some'} events`);
                                if (source.health_reason) tooltipParts.push(source.health_reason);
                                if (source.created_time) tooltipParts.push(`Created: ${new Date(source.created_time).toLocaleString()}`);
                                
                                option.title = tooltipParts.join(' | ') || 'No additional info';
                                liveGroup.appendChild(option);
                            });
                            
                            podSelector.appendChild(liveGroup);
                        }
                        
                        // Add event-only sources (non-pod objects that only have events)
                        if (eventOnlySources.length > 0 && viewMode === 'events') {
                            const eventGroup = document.createElement('optgroup');
                            eventGroup.label = "Event Sources (No Logs)";
                            
                            eventOnlySources.sort((a, b) => a.id.localeCompare(b.id)).forEach(source => {
                                const optionText = formatUnifiedOptionText(source, maxPodLength, maxContainerLength, viewMode);
                                const option = createOption(source.id, optionText, false, source);
                                option.title = `${source.eventInfo?.event_count || 'some'} events | ${source.health_reason || 'Event source'}`;
                                eventGroup.appendChild(option);
                            });
                            
                            podSelector.appendChild(eventGroup);
                        }
                        
                        // Add archived sources
                        if (archivedSources.length > 0 && viewMode === 'logs') {
                            const archivedGroup = document.createElement('optgroup');
                            archivedGroup.label = "Previous Pods";
                            
                            archivedSources.sort((a, b) => a.id.localeCompare(b.id)).forEach(source => {
                                const optionText = formatUnifiedOptionText(source, maxPodLength, maxContainerLength, viewMode);
                                const option = createOption(source.pod_name, optionText, true, source);
                                option.title = "Archived pod logs";
                                archivedGroup.appendChild(option);
                            });
                            
                            podSelector.appendChild(archivedGroup);
                        }
                    } else {
                        const noItemsText = (viewMode === 'events' ? "No event sources found" : "No pods found").padEnd(maxPodLength);
                        const noItemsContainer = "-".padEnd(maxContainerLength);
                        podSelector.innerHTML += `<option value="none">${noItemsText} | ${noItemsContainer} | ‚ùå | -</option>`;
                    }

                    // Try to restore previous selection
                    if (currentSelection) {
                        // Check if the previously selected pod still exists
                        const optionExists = Array.from(podSelector.options).some(option => option.value === currentSelection);

                        if (optionExists) {
                            podSelector.value = currentSelection;
                        } else {
                            // If the previously selected pod no longer exists, default to "all"
                            podSelector.value = "all";
                        }
                    } else {
                        // If there was no previous selection, default to "all"
                        podSelector.value = "all";
                    }

                    // Refresh data for the current selection
                    fetchAndDisplayData();
                } catch (error) {
                    // This catch is mainly for errors from /api/pods now
                    namespaceValue.textContent = 'Error loading';
                    errorDisplay.textContent = `Error fetching pod list: ${error.message}`;
                    
                    // Use default padding for error case
                    const defaultMaxPodLength = 15;
                    const defaultMaxContainerLength = 10;
                    const headerPod = "Pod".padEnd(defaultMaxPodLength);
                    const headerContainer = "Container".padEnd(defaultMaxContainerLength);
                    const errorText = "Error loading".padEnd(defaultMaxPodLength);
                    const errorContainer = "-".padEnd(defaultMaxContainerLength);
                    podSelector.innerHTML = `
                        <option value="" disabled style="font-weight: bold; color: #6b7280; background-color: #f9fafb;">‚îÄ‚îÄ ${headerPod} | ${headerContainer} | Status | Last Log ‚îÄ‚îÄ</option>
                        <option value="all">${errorText} | ${errorContainer} | ‚ùå | -</option>
                    `;
                }
            }

            async function fetchAndDisplayData() {
                if (viewMode === 'logs') {
                    return fetchAndDisplayLogs();
                } else {
                    return fetchAndDisplayEvents();
                }
            }

            async function fetchAndDisplayEvents() {
                const selectedOption = podSelector.options[podSelector.selectedIndex];
                if (!selectedOption || !selectedOption.value) {
                    logOutput.textContent = 'Please select an object to view events.';
                    currentEvents = [];
                    return;
                }

                const selectedValue = selectedOption.value;
                loadingIndicator.classList.remove('hidden');
                logOutput.textContent = '';

                const params = new URLSearchParams({
                    sort_order: sortOrder.value,
                    limit: numLines.value,
                    search_string: searchBox.value.trim(),
                    case_sensitive: caseSensitive.toString(),
                    exclude_self: excludeSelf.checked.toString(),
                });

                // Parse object selection for events
                if (selectedValue !== 'all') {
                    const [objectKind, objectName] = selectedValue.split('/');
                    if (objectKind && objectName) {
                        params.append('object_kind', objectKind);
                        params.append('object_name', objectName);
                    }
                }

                try {
                    console.log('Fetching events with params:', params.toString());
                    const data = await fetchFromServer(`/api/events?${params.toString()}`);
                    console.log('Received event data:', data);
                    if (!data.events) {
                        console.error('No events array in response:', data);
                        throw new Error('Invalid response format: missing events array');
                    }
                    currentEvents = data.events;
                    currentLogs = []; // Clear logs when viewing events
                    console.log('Setting currentEvents, length:', currentEvents.length);
                    renderEvents();
                } catch (error) {
                    console.error('Error in fetchAndDisplayEvents:', error);
                    currentEvents = [];
                    
                    let errorMessage = `Error loading events: ${error.message}`;
                    if (error.retrySuggested) {
                        errorMessage += ' (Retry recommended)';
                    }
                    errorDisplay.textContent = errorMessage;
                    
                    const errorEventEntry = {
                        error: true,
                        message: error.message,
                        error_type: error.errorType || 'unknown_error',
                        retry_suggested: error.retrySuggested !== false,
                        last_timestamp: null,
                        involved_object_name: selectedValue || 'unknown'
                    };
                    
                    currentEvents = [errorEventEntry];
                    renderEvents();
                } finally {
                    loadingIndicator.classList.add('hidden');
                }
            }

            async function fetchAndDisplayLogs() {
                const selectedOption = podSelector.options[podSelector.selectedIndex];
                if (!selectedOption || !selectedOption.value) {
                    logOutput.textContent = 'Please select a pod to view logs.';
                    currentLogs = [];
                    return;
                }

                const selectedValue = selectedOption.value;
                const isArchivedLog = selectedOption.dataset.isArchived === "true";
                const actualPodName = isArchivedLog ? selectedValue.substring("archived:".length) : selectedValue;

                loadingIndicator.classList.remove('hidden');
                logOutput.textContent = '';

                const params = new URLSearchParams({
                    pod_name: actualPodName,
                    sort_order: sortOrder.value,
                    tail_lines: numLines.value,
                    search_string: searchBox.value.trim(),
                    case_sensitive: caseSensitive.toString(),
                });

                // Add exclude_self parameter if needed
                if (excludeSelf.checked && currentPodName) {
                    params.append('exclude_self', currentPodName);
                }

                const apiEndpoint = isArchivedLog ? '/api/archived_logs' : '/api/logs';

                try {
                    // Regular fetch for non-following mode (live or archived)
                    console.log('Fetching logs with params:', params.toString());
                    const data = await fetchFromServer(`${apiEndpoint}?${params.toString()}`);
                    console.log('Received log data:', data);
                    if (!data.logs) {
                        console.error('No logs array in response:', data);
                        throw new Error('Invalid response format: missing logs array');
                    }
                    currentLogs = data.logs;
                    currentEvents = []; // Clear events when viewing logs
                    console.log('Setting currentLogs, length:', currentLogs.length);
                    renderLogs();
                } catch (error) {
                    console.error('Error in fetchAndDisplayLogs:', error);
                    currentLogs = [];
                    
                    // Create a detailed error message
                    let errorMessage = `Error loading logs: ${error.message}`;
                    if (error.retrySuggested) {
                        errorMessage += ' (Retry recommended)';
                    }
                    errorDisplay.textContent = errorMessage;
                    
                    // Create an error log entry for display
                    const errorLogEntry = {
                        error: true,
                        message: error.message,
                        error_type: error.errorType || 'unknown_error',
                        retry_suggested: error.retrySuggested !== false,
                        timestamp: null,
                        pod_name: actualPodName || 'unknown'
                    };
                    
                    currentLogs = [errorLogEntry];
                    renderLogs();
                } finally {
                    loadingIndicator.classList.add('hidden');
                }
            }

            // --- Log Rendering ---
            function renderLogs() {
                console.log('Starting renderLogs, currentLogs length:', currentLogs.length);
                logOutput.innerHTML = '';

                if (!Array.isArray(currentLogs)) {
                    console.error('currentLogs is not an array:', currentLogs);
                    errorDisplay.textContent = 'Error: Invalid log data format';
                    return;
                }

                if (currentLogs.length === 0) {
                    logOutput.textContent = 'No logs to display for the current selection.';
                    if (searchBox.value.trim() && podSelector.value) {
                         logOutput.textContent += `\nOr no logs match your search term: "${searchBox.value.trim()}"`;
                    }
                    return;
                }

                const fragment = document.createDocumentFragment();
                const searchTerm = searchBox.value.trim(); // For search highlighting

                // Use shared pod colors and color mapping
                const { podColorMap, updateColorIndex } = getOrCreateColorMapping();
                let colorIndex = globalColorIndex;

                const logColoringRules = {
                    error: {
                        terms: ['error', 'err', 'fatal', 'panic', 'exception', 'critical', 'failed', 'failure'],
                        classes: ['text-red-600', 'dark:text-red-400', 'font-semibold']
                    },
                    warning: {
                        terms: ['warning', 'warn', 'wrn'],
                        classes: ['text-orange-500', 'dark:text-orange-400']
                    },
                    info: {
                        terms: ['info', 'notice', 'inf'],
                        classes: ['text-green-600', 'dark:text-green-400']
                    },
                    debug: {
                        terms: ['debug', 'dbg', 'trace', 'trc'],
                        classes: ['text-cyan-600', 'dark:text-cyan-400']
                    }
                };

                currentLogs.forEach(logEntry => {
                    const lineDiv = document.createElement('div');
                    lineDiv.classList.add('log-line', 'py-0.5');
                    
                    // Handle error entries specially
                    if (logEntry.error) {
                        lineDiv.classList.add('log-error');
                        const errorDiv = document.createElement('div');
                        errorDiv.innerHTML = logEntry.message || 'Unknown error';
                        
                        // Add retry button if retry is suggested
                        if (logEntry.retry_suggested !== false) {
                            const retryButton = document.createElement('button');
                            retryButton.textContent = 'Retry';
                            retryButton.className = 'retry-button';
                            retryButton.onclick = () => fetchAndDisplayLogs();
                            errorDiv.appendChild(retryButton);
                        }
                        
                        lineDiv.appendChild(errorDiv);
                        fragment.appendChild(lineDiv);
                        return;
                    }

                    // Assign color to pod if viewing all pods
                    if (podSelector.value === 'all' && logEntry.pod_name) {
                        if (!podColorMap.has(logEntry.pod_name)) {
                            podColorMap.set(logEntry.pod_name, podColors[colorIndex % podColors.length]);
                            colorIndex++;
                        }
                        const podColor = podColorMap.get(logEntry.pod_name);

                        const podSpan = document.createElement('span');
                        podSpan.classList.add('mr-3', 'font-medium', ...podColor);
                        podSpan.textContent = `[${logEntry.pod_name}] `;
                        lineDiv.appendChild(podSpan);
                    }

                    const timestampSpan = document.createElement('span');
                    timestampSpan.classList.add('mr-3', 'text-gray-500', 'dark:text-gray-400', 'select-none');
                    timestampSpan.textContent = formatTimestamp(logEntry.timestamp) + ' ';

                    const messageSpan = document.createElement('span');
                    messageSpan.classList.add('log-message');

                    let messageContent = logEntry.message; // Original message content

                    // Apply keyword coloring first
                    let coloredMessageContent = messageContent;
                    const levelsInOrder = ['error', 'warning', 'info']; // Process in this order

                    for (const level of levelsInOrder) {
                        const rule = logColoringRules[level];
                        if (rule) {
                            for (const term of rule.terms) {
                                // Regex for whole word, case-insensitive
                                // \b ensures "word boundary"
                                const termRegex = new RegExp(`\\b(${escapeRegExp(term)})\\b`, 'gi');
                                coloredMessageContent = coloredMessageContent.replace(termRegex, (match) => {
                                    return `<span class="${rule.classes.join(' ')}">${match}</span>`;
                                });
                            }
                        }
                    }

                    // Apply search highlighting on the potentially colorized message
                    if (searchTerm && highlightEnabled) {
                        const searchFlags = caseSensitive ? 'g' : 'gi';
                        const searchRegex = new RegExp(`(${escapeRegExp(searchTerm)})`, searchFlags);
                        coloredMessageContent = coloredMessageContent.replace(searchRegex, (match, p1) => {
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = coloredMessageContent;
                            if (tempDiv.textContent.includes(match)) {
                                return `<mark>${p1}</mark>`;
                            }
                            return match;
                        });
                    }

                    messageSpan.innerHTML = coloredMessageContent;

                    lineDiv.appendChild(timestampSpan);
                    lineDiv.appendChild(messageSpan);
                    fragment.appendChild(lineDiv);
                });
                logOutput.appendChild(fragment);
            }

            // --- Events Rendering ---
            function renderEvents() {
                console.log('Starting renderEvents, currentEvents length:', currentEvents.length);
                logOutput.innerHTML = '';

                if (!Array.isArray(currentEvents)) {
                    console.error('currentEvents is not an array:', currentEvents);
                    errorDisplay.textContent = 'Error: Invalid event data format';
                    return;
                }

                if (currentEvents.length === 0) {
                    logOutput.textContent = 'No events to display for the current selection.';
                    if (searchBox.value.trim() && podSelector.value) {
                         logOutput.textContent += `\nOr no events match your search term: "${searchBox.value.trim()}"`;
                    }
                    return;
                }

                const fragment = document.createDocumentFragment();
                const searchTerm = searchBox.value.trim();

                // Use shared pod colors and color mapping
                const { podColorMap, updateColorIndex } = getOrCreateColorMapping();
                let colorIndex = globalColorIndex;

                // Define event type colors
                const eventTypeColors = {
                    'Warning': ['text-orange-600', 'dark:text-orange-400'],
                    'Normal': ['text-blue-600', 'dark:text-blue-400'],
                };

                // Define event reason colors
                const eventReasonColors = {
                    'error': ['text-red-600', 'dark:text-red-400', 'font-semibold'],
                    'failed': ['text-red-600', 'dark:text-red-400', 'font-semibold'],
                    'killing': ['text-red-600', 'dark:text-red-400'],
                    'created': ['text-green-600', 'dark:text-green-400'],
                    'started': ['text-green-600', 'dark:text-green-400'],
                    'pulled': ['text-green-600', 'dark:text-green-400'],
                    'scheduled': ['text-blue-600', 'dark:text-blue-400'],
                };

                currentEvents.forEach(eventEntry => {
                    const lineDiv = document.createElement('div');
                    lineDiv.classList.add('log-line', 'py-0.5');
                    
                    // Handle error entries specially
                    if (eventEntry.error) {
                        lineDiv.classList.add('log-error');
                        const errorDiv = document.createElement('div');
                        errorDiv.innerHTML = eventEntry.message || 'Unknown error';
                        
                        if (eventEntry.retry_suggested !== false) {
                            const retryButton = document.createElement('button');
                            retryButton.textContent = 'Retry';
                            retryButton.className = 'retry-button';
                            retryButton.onclick = () => fetchAndDisplayData();
                            errorDiv.appendChild(retryButton);
                        }
                        
                        lineDiv.appendChild(errorDiv);
                        fragment.appendChild(lineDiv);
                        return;
                    }

                    // Event timestamp
                    const timestampSpan = document.createElement('span');
                    timestampSpan.classList.add('mr-3', 'text-gray-500', 'dark:text-gray-400', 'select-none');
                    timestampSpan.textContent = formatTimestamp(eventEntry.last_timestamp || eventEntry.first_timestamp) + ' ';

                    // Event type with color coding
                    const typeSpan = document.createElement('span');
                    const typeColors = eventTypeColors[eventEntry.type] || ['text-gray-600', 'dark:text-gray-400'];
                    typeSpan.classList.add('mr-2', 'font-medium', ...typeColors);
                    typeSpan.textContent = `[${eventEntry.type || 'Unknown'}]`;

                    // Event reason with color coding
                    const reasonSpan = document.createElement('span');
                    const reasonLower = (eventEntry.reason || '').toLowerCase();
                    let reasonColors = ['text-gray-700', 'dark:text-gray-300'];
                    
                    for (const [keyword, colors] of Object.entries(eventReasonColors)) {
                        if (reasonLower.includes(keyword)) {
                            reasonColors = colors;
                            break;
                        }
                    }
                    
                    reasonSpan.classList.add('mr-2', 'font-medium', ...reasonColors);
                    reasonSpan.textContent = `${eventEntry.reason || 'Unknown'}:`;

                    // Object info (if viewing all events) - with unique colors per object
                    if (podSelector.value === 'all' && eventEntry.involved_object_kind && eventEntry.involved_object_name) {
                        const objectKey = `${eventEntry.involved_object_kind}/${eventEntry.involved_object_name}`;
                        
                        // Use the same color mapping logic as logs
                        if (!podColorMap.has(objectKey)) {
                            podColorMap.set(objectKey, podColors[colorIndex % podColors.length]);
                            colorIndex++;
                        }
                        const objectColor = podColorMap.get(objectKey);

                        const objectSpan = document.createElement('span');
                        objectSpan.classList.add('mr-2', 'font-medium', ...objectColor);
                        objectSpan.textContent = objectKey;
                        lineDiv.appendChild(objectSpan);
                    }

                    // Event message
                    const messageSpan = document.createElement('span');
                    messageSpan.classList.add('event-message');

                    let messageContent = eventEntry.message || 'No message';

                    // Apply search highlighting
                    if (searchTerm && highlightEnabled) {
                        const searchFlags = caseSensitive ? 'g' : 'gi';
                        const searchRegex = new RegExp(`(${escapeRegExp(searchTerm)})`, searchFlags);
                        messageContent = messageContent.replace(searchRegex, '<mark>$1</mark>');
                    }

                    messageSpan.innerHTML = messageContent;

                    lineDiv.appendChild(timestampSpan);
                    lineDiv.appendChild(typeSpan);
                    lineDiv.appendChild(reasonSpan);
                    lineDiv.appendChild(messageSpan);
                    fragment.appendChild(lineDiv);
                });
                
                logOutput.appendChild(fragment);
                
                // Update the global color index
                updateColorIndex(colorIndex);
            }

            function escapeRegExp(string) {
                return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }

            // --- Timestamp Formatting ---
            function formatTimestamp(utcTimestamp) {
                if (!utcTimestamp) return "[No Timestamp]";
                const date = new Date(utcTimestamp);
                if (isNaN(date)) return "[Invalid Date]";

                if (timestampType.value === 'utc') {
                    return date.toISOString();
                } else {
                    return timeSince(date);
                }
            }

            function timeSince(date) {
                const seconds = Math.floor((new Date() - date) / 1000);
                let interval = seconds / 31536000;
                if (interval > 1) return Math.floor(interval) + "y ago";
                interval = seconds / 2592000;
                if (interval > 1) return Math.floor(interval) + "mo ago";
                interval = seconds / 86400;
                if (interval > 1) return Math.floor(interval) + "d ago";
                interval = seconds / 3600;
                if (interval > 1) return Math.floor(interval) + "h ago";
                interval = seconds / 60;
                if (interval > 1) return Math.floor(interval) + "m ago";
                if (seconds < 0) return "just now";
                return Math.max(0, Math.floor(seconds)) + "s ago";
            }

            // --- Event Listeners ---
            podSelector.addEventListener('change', () => {
                logOutput.textContent = '';
                currentLogs = [];
                currentEvents = [];
                fetchAndDisplayData();
            });
            sortOrder.addEventListener('change', fetchAndDisplayData);
            numLines.addEventListener('change', fetchAndDisplayData);
            timestampType.addEventListener('change', () => {
                if (viewMode === 'logs') {
                    renderLogs();
                } else {
                    renderEvents();
                }
            });

            searchBox.addEventListener('keypress', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    fetchAndDisplayData();
                }
            });

            clearSearch.addEventListener('click', (event) => {
                event.preventDefault();
                searchBox.value = '';
                fetchAndDisplayData();
            });

            refreshPods.addEventListener('click', (event) => {
                event.preventDefault();
                const currentSelection = podSelector.value; // Store current selection
                loadingIndicator.classList.remove('hidden');
                if (viewMode === 'logs') {
                    fetchPodsAndRestoreSelection(currentSelection).finally(() => {
                        loadingIndicator.classList.add('hidden');
                    });
                } else {
                    fetchEventSourcesAndRestoreSelection(currentSelection).finally(() => {
                        loadingIndicator.classList.add('hidden');
                    });
                }
            });

            // Settings menu toggle
            settingsButton.addEventListener('click', (event) => {
                event.stopPropagation();
                settingsMenu.classList.toggle('hidden');
            });

            // Close settings menu when clicking outside
            document.addEventListener('click', (event) => {
                if (!settingsMenu.contains(event.target) && !settingsButton.contains(event.target)) {
                    settingsMenu.classList.add('hidden');
                }
            });

            // Prevent menu from closing when clicking inside it
            settingsMenu.addEventListener('click', (event) => {
                event.stopPropagation();
            });

            // Add event listener for excludeSelf checkbox
            excludeSelf.addEventListener('change', () => {
                const currentSelection = podSelector.value; // Store current selection
                loadingIndicator.classList.remove('hidden');
                if (viewMode === 'logs') {
                    fetchPodsAndRestoreSelection(currentSelection).finally(() => {
                        loadingIndicator.classList.add('hidden');
                    });
                } else {
                    fetchEventSourcesAndRestoreSelection(currentSelection).finally(() => {
                        loadingIndicator.classList.add('hidden');
                    });
                }
            });

            // Initial data fetch
            fetchUnifiedSources();
            fetchVersion();
        });
    </script>
</body>
</html>